<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Parser</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Parser.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2020 Composewell Technologies</td></tr><tr><th>License</th><td>BSD-3-Clause</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Parser</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Accumulators</a></li><li><a href="#g:2">Element parsers</a></li><li><a href="#g:3">Sequence parsers</a></li><li><a href="#g:4">Binary Combinators</a><ul><li><a href="#g:5">Sequential Applicative</a></li><li><a href="#g:6">Parallel Applicatives</a></li><li><a href="#g:7">Sequential Interleaving</a></li><li><a href="#g:8">Sequential Alternative</a></li><li><a href="#g:9">Parallel Alternatives</a></li></ul></li><li><a href="#g:10">N-ary Combinators</a><ul><li><a href="#g:11">Sequential Collection</a></li><li><a href="#g:12">Sequential Repetition</a></li><li><a href="#g:13">Special cases</a></li></ul></li><li><a href="#g:14">Distribution</a><ul><li><a href="#g:15">Distribute to collection</a></li><li><a href="#g:16">Distribute to repetition</a></li><li><a href="#g:17">Interleaved collection</a></li><li><a href="#g:18">Collection of Alternatives</a></li><li><a href="#g:19">Repeated Alternatives</a></li></ul></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Fast backtracking parsers with stream fusion and native streaming
 capability.</p><p><code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:Alternative" title="Control.Applicative">Alternative</a></code> type class based
 combinators from the
 <a href="http://hackage.haskell.org/package/parser-combinators">parser-combinators</a>
 package can also be used with the <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> type. However, there are two
 important differences between <code>parser-combinators</code> and the equivalent ones
 provided in this module in terms of performance:</p><p>1) <code>parser-combinators</code> use plain Haskell lists to collect the results, in a
 strict Monad like IO, the results are necessarily buffered before they can
 be consumed.  This may not perform optimally in streaming applications
 processing large amounts of data.  Equivalent combinators in this module can
 consume the results of parsing using a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>, thus providing a scalability
 and a composable consumer.</p><p>2) Several combinators in this module can be many times faster because of
 stream fusion. For example, <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> combinator
 in this module is much faster than the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code> combinator
 of <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:Alternative" title="Control.Applicative">Alternative</a></code> type class.</p><h1>Errors</h1><p>Failing parsers in this module throw the <code><a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></code> exception.</p><h1>Naming</h1><p>As far as possible, try that the names of the combinators in this module are
 consistent with:</p><ul><li><a href="https://hackage.haskell.org/package/base/docs/Text-ParserCombinators-ReadP.html">base/Text.ParserCombinators.ReadP</a></li><li><a href="http://hackage.haskell.org/package/parser-combinators">parser-combinators</a></li><li><a href="http://hackage.haskell.org/package/megaparsec">megaparsec</a></li><li><a href="http://hackage.haskell.org/package/attoparsec">attoparsec</a></li><li><a href="http://hackage.haskell.org/package/parsec">parsec</a></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">newtype</span> <a href="#t:Parser">Parser</a> m a b = <a href="#v:MkParser">MkParser</a> {<ul class="subs"><li><a href="#v:runParser">runParser</a> :: <span class="keyword">forall</span> r. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; ((<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; Parse b -&gt; m (Driver m a r)) -&gt; m (Driver m a r)</li></ul>}</li><li class="src short"><span class="keyword">newtype</span> <a href="#t:ParseError">ParseError</a> = <a href="#v:ParseError">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:Step">Step</a> s b<ul class="subs"><li>= <a href="#v:Partial">Partial</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Continue">Continue</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</li><li>| <a href="#v:Done">Done</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</li><li>| <a href="#v:Error">Error</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></li></ul></li><li class="src short"><a href="#v:fromFold">fromFold</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:any">any</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:yield">yield</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:die">die</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:dieM">dieM</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:peek">peek</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:eof">eof</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:satisfy">satisfy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a</li><li class="src short"><a href="#v:maybe">maybe</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:either">either</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeBetween">takeBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:take">take</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeEQ">takeEQ</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeGE">takeGE</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:lookAhead">lookAhead</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhileP">takeWhileP</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:takeWhile1">takeWhile1</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepByP">sliceSepByP</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepBy">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepByMax">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceEndWith">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceBeginWith">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:sliceSepWith">sliceSepWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:escapedSliceSepBy">escapedSliceSepBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:escapedFrameBy">escapedFrameBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:wordBy">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:groupBy">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:eqBy">eqBy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a ()</li><li class="src short"><a href="#v:splitWith">splitWith</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:split_">split_</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b</li><li class="src short"><a href="#v:teeWith">teeWith</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithFst">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:teeWithMin">teeWithMin</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c</li><li class="src short"><a href="#v:deintercalate">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z)</li><li class="src short"><a href="#v:alt">alt</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:shortest">shortest</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:longest">longest</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a</li><li class="src short"><a href="#v:sequence">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:count">count</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:countBetween">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyP">manyP</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:many">many</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:some">some</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyTillP">manyTillP</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyTill">manyTill</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:manyThen">manyThen</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:roundRobin">roundRobin</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:choice">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li><li class="src short"><a href="#v:retryMaxTotal">retryMaxTotal</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:retryMaxSuccessive">retryMaxSuccessive</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c</li><li class="src short"><a href="#v:retry">retry</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b</li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:Parser" class="def">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#Parser" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></p><div class="doc"><p>A continuation passing style parser representation.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:MkParser" class="def">MkParser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:runParser" class="def">runParser</a> :: <span class="keyword">forall</span> r. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; ((<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; Parse b -&gt; m (Driver m a r)) -&gt; m (Driver m a r)</dfn><div class="doc empty">&nbsp;</div></li></ul></div></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Parser">Instances</h4><details id="i:Parser" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Monad:1"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-373" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Monad composition can be used for lookbehind parsers, we can make the
 future parses depend on the previously parsed values.</p><p>If we have to parse &quot;a9&quot; or &quot;9a&quot; but not &quot;99&quot; or &quot;aa&quot; we can use the
 following parser:</p><pre>backtracking :: MonadCatch m =&gt; PR.Parser m Char String
backtracking =
    sequence [PR.satisfy isDigit, PR.satisfy isAlpha]
    <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>
    sequence [PR.satisfy isAlpha, PR.satisfy isDigit]
</pre><p>We know that if the first parse resulted in a digit at the first place then
 the second parse is going to fail.  However, we waste that information and
 parse the first character again in the second parse only to know that it is
 not an alphabetic char.  By using lookbehind in a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> composition we can
 avoid redundant work:</p><pre>data DigitOrAlpha = Digit Char | Alpha Char

lookbehind :: MonadCatch m =&gt; PR.Parser m Char String
lookbehind = do
    x1 &lt;-    Digit <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isDigit
         <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code> Alpha <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#v:-60--36--62-" title="Data.Functor">&lt;$&gt;</a></code> PR.satisfy isAlpha

    -- Note: the parse depends on what we parsed already
    x2 &lt;- case x1 of
        Digit _ -&gt; PR.satisfy isAlpha
        Alpha _ -&gt; PR.satisfy isDigit

    return $ case x1 of
        Digit x -&gt; [x,x2]
        Alpha x -&gt; [x,x2]
</pre><p>See also <code><a href="Streamly-Internal-Data-Parser.html#v:concatMap" title="Streamly.Internal.Data.Parser">concatMap</a></code>. This monad instance
 does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:concatMap" title="Streamly.Internal.Data.Parser">concatMap</a></code> when you need
 fusion.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Monad:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; (a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-262" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p>Maps a function over the output of the parser.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:MonadFail:3"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-Fail.html#t:MonadFail" title="Control.Monad.Fail">MonadFail</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-394" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Parser:MonadFail:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fail">fail</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:fail" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Applicative:4"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-294" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> form of <code><a href="Streamly-Internal-Data-Parser.html#v:splitWith" title="Streamly.Internal.Data.Parser">splitWith</a></code>. Note that
 this operation does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:splitWith" title="Streamly.Internal.Data.Parser">splitWith</a></code>
 when fusion is important.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Applicative:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a (a0 -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a0 -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:Alternative:5"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-416" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> form of <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code>. Backtrack and
 run the second parser if the first one fails.</p><p>The &quot;some&quot; and &quot;many&quot; operations of alternative accumulate results in a pure
 list which is not scalable and streaming. Instead use
 <code><a href="Streamly-Internal-Data-Parser.html#v:some" title="Streamly.Internal.Data.Parser">some</a></code> and
 <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> for fusible operations with composable
 accumulation of results.</p><p>See also <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code>. This <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Alternative" title="Control.Applicative">Alternative</a></code> instance
 does not fuse, use <code><a href="Streamly-Internal-Data-Parser.html#v:alt" title="Streamly.Internal.Data.Parser">alt</a></code> when you need
 fusion.</p></td></tr><tr><td colspan="2"><details id="i:id:Parser:Alternative:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:empty">empty</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:empty" class="selflink">#</a></p><p class="src"><a href="#v:-60--124--62-">(&lt;|&gt;)</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:-60--124--62-" class="selflink">#</a></p><p class="src"><a href="#v:some">some</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:some" class="selflink">#</a></p><p class="src"><a href="#v:many">many</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a [a0] <a href="#v:many" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Parser:MonadPlus:6"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:MonadPlus" title="Control.Monad">MonadPlus</a> (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a)</span> <a href="src/Streamly.Internal.Data.Parser.ParserK.Types.html#line-451" class="link">Source</a> <a href="#t:Parser" class="selflink">#</a></td><td class="doc"><p><code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#v:mzero" title="Control.Monad">mzero</a></code> is same as <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:empty" title="Control.Applicative">empty</a></code>, it aborts the parser. <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#v:mplus" title="Control.Monad">mplus</a></code> is same as
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-60--124--62-" title="Control.Applicative">&lt;|&gt;</a></code>, it selects the first succeeding parser.</p><p><em>Internal</em></p></td></tr><tr><td colspan="2"><details id="i:id:Parser:MonadPlus:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserK-Types.html">Streamly.Internal.Data.Parser.ParserK.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mzero">mzero</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mzero" class="selflink">#</a></p><p class="src"><a href="#v:mplus">mplus</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a0 <a href="#v:mplus" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a id="t:ParseError" class="def">ParseError</a> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#ParseError" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></p><div class="doc"><p>This exception is used for two purposes:</p><ul><li>When a parser ultimately fails, the user of the parser is intimated via
    this exception.</li><li>When the &quot;extract&quot; function of a parser needs to throw an error.</li></ul><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:ParseError" class="def">ParseError</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ParseError">Instances</h4><details id="i:ParseError" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Show:1"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-233" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a>] -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParseError:Exception:2"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-235" class="link">Source</a> <a href="#t:ParseError" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParseError:Exception:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toException">toException</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> <a href="#v:toException" class="selflink">#</a></p><p class="src"><a href="#v:fromException">fromException</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:SomeException" title="Control.Exception.Base">SomeException</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> <a href="#v:fromException" class="selflink">#</a></p><p class="src"><a href="#v:displayException">displayException</a> :: <a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:displayException" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Step" class="def">Step</a> s b <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#Step" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></p><div class="doc"><p>The return type of a <code><a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a></code> step.</p><p>The parse operation feeds the input stream to the parser one element at a
 time, representing a parse <code><a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a></code>. The parser may or may not consume the
 item and returns a result. If the result is <code><a href="Streamly-Internal-Data-Parser.html#v:Partial" title="Streamly.Internal.Data.Parser">Partial</a></code> we can either extract
 the result or feed more input to the parser. If the result is <code><a href="Streamly-Internal-Data-Parser.html#v:Continue" title="Streamly.Internal.Data.Parser">Continue</a></code>, we
 must feed more input in order to get a result. If the parser returns <code><a href="Streamly-Internal-Data-Parser.html#v:Done" title="Streamly.Internal.Data.Parser">Done</a></code>
 then the parser can no longer take any more input.</p><p>If the result is <code><a href="Streamly-Internal-Data-Parser.html#v:Continue" title="Streamly.Internal.Data.Parser">Continue</a></code>, the parse operation retains the input in a
 backtracking buffer, in case the parser may ask to backtrack in future.
 Whenever a 'Partial n' result is returned we first backtrack by <code>n</code> elements
 in the input and then release any remaining backtracking buffer. Similarly,
 'Continue n' backtracks to <code>n</code> elements before the current position and
 starts feeding the input from that point for future invocations of the
 parser.</p><p>If parser is not yet done, we can use the <code>extract</code> operation on the <code>state</code>
 of the parser to extract a result. If the parser has not yet yielded a
 result, the operation fails with a <code><a href="Streamly-Internal-Data-Parser.html#t:ParseError" title="Streamly.Internal.Data.Parser">ParseError</a></code> exception. If the parser
 yielded a <code><a href="Streamly-Internal-Data-Parser.html#v:Partial" title="Streamly.Internal.Data.Parser">Partial</a></code> result in the past the last partial result is returned.
 Therefore, if a parser yields a partial result once it cannot fail later on.</p><p>The parser can never backtrack beyond the position where the last partial
 result left it at. The parser must ensure that the backtrack position is
 always after that.</p><p><em>Internal</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Partial" class="def">Partial</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p>Partial result with an optional backtrack request.</p><p><code>Partial count state</code> means a partial result is available which
 can be extracted successfully, <code>state</code> is the opaque state of the
 parser to be supplied to the next invocation of the step operation.
 The current input position is reset to <code>count</code> elements back and any
 input before that is dropped from the backtrack buffer.</p></td></tr><tr><td class="src"><a id="v:Continue" class="def">Continue</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> s</td><td class="doc"><p>Need more input with an optional backtrack request.</p><p><code>Continue count state</code> means the parser has consumed the current input
 but no new result is generated, <code>state</code> is the next state of the parser.
 The current input is retained in the backtrack buffer and the input
 position is reset to <code>count</code> elements back.</p></td></tr><tr><td class="src"><a id="v:Done" class="def">Done</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b</td><td class="doc"><p>Done with leftover input count and result.</p><p><code>Done count result</code> means the parser has finished, it will accept no
 more input, last <code>count</code> elements from the input are unused and the
 result of the parser is in <code>result</code>.</p></td></tr><tr><td class="src"><a id="v:Error" class="def">Error</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></td><td class="doc"><p>Parser failed without generating any output.</p><p>The parsing operation may backtrack to the beginning and try another
 alternative.</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Step">Instances</h4><details id="i:Step" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Step:Functor:1"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s)</span> <a href="src/Streamly.Internal.Data.Parser.ParserD.Types.html#line-203" class="link">Source</a> <a href="#t:Step" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Step:Functor:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Parser-ParserD-Types.html">Streamly.Internal.Data.Parser.ParserD.Types</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Step" title="Streamly.Internal.Data.Parser">Step</a> s a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><a href="#g:1" id="g:1"><h1>Accumulators</h1></a><div class="top"><p class="src"><a id="v:fromFold" class="def">fromFold</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#fromFold" class="link">Source</a> <a href="#v:fromFold" class="selflink">#</a></p><div class="doc"><p>Make a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> from a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.any (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; True
</pre></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Parser.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.all (== 0)) $ S.fromList [1,0,1]
</code></strong>&gt; False
</pre></div></div><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><p>A parser that always yields a pure value without consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; m b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><p>A parser that always yields the result of an effectful action without
 consuming any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:die" class="def">die</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#die" class="link">Source</a> <a href="#v:die" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an error message without consuming
 any input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dieM" class="def">dieM</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#dieM" class="link">Source</a> <a href="#v:dieM" class="selflink">#</a></p><div class="doc"><p>A parser that always fails with an effectful error message and without
 consuming any input.</p><p><em>Internal</em></p></div></div><a href="#g:2" id="g:2"><h1>Element parsers</h1></a><div class="top"><p class="src"><a id="v:peek" class="def">peek</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#peek" class="link">Source</a> <a href="#v:peek" class="selflink">#</a></p><div class="doc"><p>Peek the head element of a stream, without consuming it. Fails if it
 encounters end of input.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.peek &lt;*&gt; PR.satisfy (&gt; 0)) $ S.fromList [1]
</code></strong>(1,1)
</pre><pre>peek = lookAhead (satisfy True)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:eof" class="def">eof</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eof" class="link">Source</a> <a href="#v:eof" class="selflink">#</a></p><div class="doc"><p>Succeeds if we are at the end of input, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse ((,) &lt;$&gt; PR.satisfy (&gt; 0) &lt;*&gt; PR.eof) $ S.fromList [1]
</code></strong>&gt; (1,())
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:satisfy" class="def">satisfy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a a <a href="src/Streamly.Internal.Data.Parser.html#satisfy" class="link">Source</a> <a href="#v:satisfy" class="selflink">#</a></p><div class="doc"><p>Returns the next element if it passes the predicate, fails otherwise.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (== 1)) $ S.fromList [1,0,1]
</code></strong>&gt; 1
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:maybe" class="def">maybe</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#maybe" class="link">Source</a> <a href="#v:maybe" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> returning function on the next element in the stream. The
 parser fails if the function returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> otherwise returns the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>
 value.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:either" class="def">either</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#either" class="link">Source</a> <a href="#v:either" class="selflink">#</a></p><div class="doc"><p>Map an <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> returning function on the next element in the stream.  If
 the function returns 'Left err', the parser fails with the error message
 <code>err</code> otherwise returns the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Right" title="Data.Either">Right</a></code> value.</p><p><em>Internal</em></p></div></div><a href="#g:3" id="g:3"><h1>Sequence parsers</h1></a><div class="doc"><p>Parsers chained in series, if one parser terminates the composition
 terminates.</p></div><div class="doc"><p>Grab a sequence of input elements without inspecting them</p></div><div class="top"><p class="src"><a id="v:takeBetween" class="def">takeBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeBetween" class="link">Source</a> <a href="#v:takeBetween" class="selflink">#</a></p><div class="doc"><p><code>takeBetween m n</code> takes a minimum of <code>m</code> and a maximum of <code>n</code> input
 elements and folds them using the supplied fold.</p><p>Stops after <code>n</code> elements.
 Fails if the stream ends before <code>m</code> elements could be taken.</p><p><code>takeBetween</code> is the most general take operation, other take operations can
 be defined in terms of takeBetween. For example:</p><pre>take = takeBetween 0 n  -- equivalent of takeLE
take1 = takeBetween 1 n -- equivalent of takeLE1
takeEQ = takeBetween n n
takeGE = takeBetween n maxBound
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take at most <code>n</code> input elements and fold them using the supplied fold.</p><p>Stops after <code>n</code> elements.
 Never fails.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.take 1 FL.toList) $ S.fromList [1]
</code></strong>[1]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.take (-1) FL.toList) $ S.fromList [1]
</code></strong>[]
</pre><pre>S.chunksOf n f = S.parseMany (FL.take n f)
</pre><p><em>Internal</em></p></div></div><div class="doc"><p>Note: this is called takeP in some parser libraries.</p><p>TODO Once we have terminating folds, this Parse should get replaced by Fold.
 Alternatively, we can name it &quot;chunkOf&quot; and the corresponding time domain
 combinator as &quot;intervalOf&quot; or even &quot;chunk&quot; and &quot;interval&quot;.</p></div><div class="top"><p class="src"><a id="v:takeEQ" class="def">takeEQ</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeEQ" class="link">Source</a> <a href="#v:takeEQ" class="selflink">#</a></p><div class="doc"><p>Stops after taking exactly <code>n</code> input elements.</p><ul><li>Stops - after <code>n</code> elements.</li><li>Fails - if the stream ends before it can collect <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeEQ 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeEQ: Expecting exactly 4 elements, got 3&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeGE" class="def">takeGE</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeGE" class="link">Source</a> <a href="#v:takeGE" class="selflink">#</a></p><div class="doc"><p>Take at least <code>n</code> input elements, but can collect more.</p><ul><li>Stops - never.</li><li>Fails - if the stream end before producing <code>n</code> elements.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1]
</code></strong>&gt; &quot;takeGE: Expecting at least 4 elements, got only 3&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeGE 4 FL.toList) $ S.fromList [1,0,1,0,1]
</code></strong>&gt; [1,0,1,0,1]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:lookAhead" class="def">lookAhead</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#lookAhead" class="link">Source</a> <a href="#v:lookAhead" class="selflink">#</a></p><div class="doc"><p>Run a parser without consuming the input.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileP" class="def">takeWhileP</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhileP" class="link">Source</a> <a href="#v:takeWhileP" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code> but uses a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> instead of a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> to collect the
 input. The combinator stops when the condition fails or if the collecting
 parser stops.</p><p>This is a generalized version of takeWhile, for example <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile1" title="Streamly.Internal.Data.Parser">takeWhile1</a></code> can be
 implemented in terms of this:</p><pre>takeWhile1 cond p = takeWhile cond (takeBetween 1 maxBound p)
</pre><p>Stops: when the condition fails or the collecting parser stops.
 Fails: when the collecting parser fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element fails the predicate. The element
 on which the predicate fails is returned back to the input stream.</p><ul><li>Stops - when the predicate fails.</li><li>Fails - never.</li></ul><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.takeWhile (== 0) FL.toList) $ S.fromList [0,0,1,0,1]
</code></strong>&gt; [0,0]
</pre><p>We can implement a <code>breakOn</code> using <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code>:</p><pre>breakOn p = takeWhile (not p)
</pre><p><em>Internal</em></p></div></div><div class="doc"><p>Note: This is called <code>takeWhileP</code> and <code>munch</code> in some parser libraries.</p></div><div class="top"><p class="src"><a id="v:takeWhile1" class="def">takeWhile1</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#takeWhile1" class="link">Source</a> <a href="#v:takeWhile1" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:takeWhile" title="Streamly.Internal.Data.Parser">takeWhile</a></code> but takes at least one element otherwise fails.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepByP" class="def">sliceSepByP</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepByP" class="link">Source</a> <a href="#v:sliceSepByP" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:sliceSepBy" title="Streamly.Internal.Data.Parser">sliceSepBy</a></code> but uses a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> instead of a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> to collect the
 input. <code>sliceSepByP cond parser</code> parses a slice of the input using <code>parser</code>
 until <code>cond</code> succeeds or the parser stops.</p><p>This is a generalized slicing parser which can be used to implement other
 parsers e.g.:</p><pre>sliceSepByMax cond n p = sliceBy cond (take n p)
sliceSepByBetween cond m n p = sliceBy cond (takeBetween m n p)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepBy" class="def">sliceSepBy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepBy" class="link">Source</a> <a href="#v:sliceSepBy" class="selflink">#</a></p><div class="doc"><p>Split on an infixed separator element, dropping the separator. Splits the
 stream on separator elements determined by the supplied predicate, separator
 is considered as infixed between two segments, if one side of the separator
 is missing then it is parsed as an empty stream.  The supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> is
 applied on the split segments. With <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing non-separator elements
 and <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code>splitOn</code> splits as follows:</p><pre>&quot;--.--&quot; =&gt; &quot;--&quot; &quot;--&quot;
&quot;--.&quot;   =&gt; &quot;--&quot; &quot;&quot;
&quot;.--&quot;   =&gt; &quot;&quot;   &quot;--&quot;
</pre><p><code>PR.sliceSepBy (== x)</code> is an inverse of <code>S.intercalate (S.yield x)</code></p><p>Let's use the following definition for illustration:</p><pre>splitOn p = PR.many FL.toList $ PR.sliceSepBy p (FL.toList)
splitOn' p = S.parse (splitOn p) . S.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepByMax" class="def">sliceSepByMax</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepByMax" class="link">Source</a> <a href="#v:sliceSepByMax" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:sliceSepBy" title="Streamly.Internal.Data.Parser">sliceSepBy</a></code> but terminates a parse even before the separator
 is encountered if its size exceeds the specified maximum limit.</p><pre>take n = PR.sliceSepByMax (const True) n
sliceSepBy p = PR.sliceSepByMax p maxBound</pre><p>Let's use the following definitions for illustration:</p><pre>splitOn p n = PR.many FL.toList $ PR.sliceSepByMax p n (FL.toList)
splitOn' p n = S.parse (splitOn p n) . S.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;a&quot;
</code></strong>infinite list of empty strings
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 3 &quot;hello.world&quot;
</code></strong>[&quot;hel&quot;,&quot;lo&quot;,&quot;wor&quot;,&quot;ld&quot;]
</pre><p>If the separator is found and the limit is reached at the same time then it
 behaves just like <code><a href="Streamly-Internal-Data-Parser.html#v:sliceSepBy" title="Streamly.Internal.Data.Parser">sliceSepBy</a></code> i.e. the separator is dropped.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') 0 &quot;..&quot;
</code></strong>[&quot;&quot;,&quot;&quot;,&quot;&quot;]
</pre><ul><li>Stops - when the predicate succeeds or the limit is reached.</li><li>Fails - never.</li></ul><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:sliceEndWith" class="def">sliceEndWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceEndWith" class="link">Source</a> <a href="#v:sliceEndWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an element succeeds the predicate. Also take
 the element on which the predicate succeeded. The succeeding element is
 treated as a suffix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds.</li><li>Fails - never.</li></ul><p>S.splitWithSuffix pred f = S.parseMany (PR.sliceEndWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sliceBeginWith" class="def">sliceBeginWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceBeginWith" class="link">Source</a> <a href="#v:sliceBeginWith" class="selflink">#</a></p><div class="doc"><p>Collect stream elements until an elements passes the predicate, return the
 last element on which the predicate succeeded back to the input stream.  If
 the predicate succeeds on the first element itself then it is kept in the
 stream and we continue collecting. The succeeding element is treated as a
 prefix separator which is kept in the output segement.</p><ul><li>Stops - when the predicate succeeds in non-leading position.</li><li>Fails - never.</li></ul><p>S.splitWithPrefix pred f = S.parseMany (PR.sliceBeginWith pred f)</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:sliceSepWith" class="def">sliceSepWith</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#sliceSepWith" class="link">Source</a> <a href="#v:sliceSepWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:sliceSepBy" title="Streamly.Internal.Data.Parser">sliceSepBy</a></code> but does not drop the separator element, instead
 separator is emitted as a separate element in the output.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:escapedSliceSepBy" class="def">escapedSliceSepBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#escapedSliceSepBy" class="link">Source</a> <a href="#v:escapedSliceSepBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:sliceSepBy" title="Streamly.Internal.Data.Parser">sliceSepBy</a></code> but the separator elements can be escaped using an
 escape char determined by the second predicate.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:escapedFrameBy" class="def">escapedFrameBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#escapedFrameBy" class="link">Source</a> <a href="#v:escapedFrameBy" class="selflink">#</a></p><div class="doc"><p><code>escapedFrameBy begin end escape</code> parses a string framed using <code>begin</code> and
 <code>end</code> as the frame begin and end marker elements and <code>escape</code> as an escaping
 element to escape the occurrence of the framing elements within the frame.
 Nested frames are allowed, but nesting is removed when parsing.</p><p>For example,</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>escapedFrameBy (== '{') (== '}') (== '\\') S.toList $ S.fromList &quot;{hello}&quot;
</code></strong>&gt; &quot;hello&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>escapedFrameBy (== '{') (== '}') (== '\\') S.toList $ S.fromList &quot;{hello {world}}&quot;
</code></strong>&gt; &quot;hello world&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>escapedFrameBy (== '{') (== '}') (== '\\') S.toList $ S.fromList &quot;{hello \\{world\\}}&quot;
</code></strong>&gt; &quot;hello {world}&quot;
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>escapedFrameBy (== '{') (== '}') (== '\\') S.toList $ S.fromList &quot;{hello {world}&quot;
</code></strong>&gt; ParseError &quot;Unterminated '{'&quot;
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:wordBy" class="def">wordBy</a> :: (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#wordBy" class="link">Source</a> <a href="#v:wordBy" class="selflink">#</a></p><div class="doc"><p>Like <code>splitOn</code> but strips leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> having <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><ul><li>Stops - when it finds a word separator after a non-word element</li><li>Fails - never.</li></ul><pre>S.wordsBy pred f = S.parseMany (PR.wordBy pred f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:groupBy" class="def">groupBy</a> :: (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#groupBy" class="link">Source</a> <a href="#v:groupBy" class="selflink">#</a></p><div class="doc"><p><code>groupBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, then if <code>a `cmp` b</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> <code>b</code> is also assigned to the same
 group.  If <code>a `cmp` c</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> <code>f</code> and the result of the fold is emitted
 in the output stream.</p><ul><li>Stops - when the comparison fails.</li><li>Fails - never.</li></ul><pre>S.groupsBy cmp f = S.parseMany (PR.groupBy cmp f)
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:eqBy" class="def">eqBy</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a () <a href="src/Streamly.Internal.Data.Parser.html#eqBy" class="link">Source</a> <a href="#v:eqBy" class="selflink">#</a></p><div class="doc"><p>Match the given sequence of elements using the given comparison function.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse $ S.eqBy (==) &quot;string&quot; $ S.fromList &quot;string&quot;
</code></strong></pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse $ S.eqBy (==) &quot;mismatch&quot; $ S.fromList &quot;match&quot;
</code></strong>&gt; *** Exception: ParseError &quot;eqBy: failed, yet to match 7 elements&quot;
</pre><p><em>Internal</em></p></div></div><div class="doc"><p>Unimplemented</p><pre>, prefixOf -- match any prefix of a given string
, suffixOf -- match any suffix of a given string
, infixOf -- match any substring of a given string
</pre></div><a href="#g:4" id="g:4"><h1>Binary Combinators</h1></a><a href="#g:5" id="g:5"><h2>Sequential Applicative</h2></a><div class="top"><p class="src"><a id="v:splitWith" class="def">splitWith</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#splitWith" class="link">Source</a> <a href="#v:splitWith" class="selflink">#</a></p><div class="doc"><p>Sequential parser application. Apply two parsers sequentially to an input
 stream.  The input is provided to the first parser, when it is done the
 remaining input is provided to the second parser. If both the parsers
 succeed their outputs are combined using the supplied function. The
 operation fails if any of the parsers fail.</p><p>Note: This is a parsing dual of appending streams using
 <code><a href="Streamly-Prelude.html#v:serial" title="Streamly.Prelude">serial</a></code>, it splits the streams using two parsers and zips
 the results.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.splitWith const (PR.satisfy (&gt; 0)) undefined) $ S.fromList [1]
</code></strong></pre><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-60--42--62-" title="Control.Applicative">&lt;*&gt;</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be faster than <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:split_" class="def">split_</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b <a href="src/Streamly.Internal.Data.Parser.html#split_" class="link">Source</a> <a href="#v:split_" class="selflink">#</a></p><div class="doc"><p>Sequential parser application ignoring the output of the first parser.
 Apply two parsers sequentially to an input stream.  The input is provided to
 the first parser, when it is done the remaining input is provided to the
 second parser. The output of the parser is the output of the second parser.
 The operation fails if any of the parsers fail.</p><p>This implementation is strict in the second argument, therefore, the
 following will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (split_ (PR.satisfy (&gt; 0)) undefined) $ S.fromList [1]
</code></strong></pre><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:-42--62-" title="Control.Applicative">*&gt;</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations, and can be faster than <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a></code> instance for small
 number (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><a href="#g:6" id="g:6"><h2>Parallel Applicatives</h2></a><div class="top"><p class="src"><a id="v:teeWith" class="def">teeWith</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWith" class="link">Source</a> <a href="#v:teeWith" class="selflink">#</a></p><div class="doc"><p><code>teeWith f p1 p2</code> distributes its input to both <code>p1</code> and <code>p2</code> until both
 of them succeed or anyone of them fails and combines their output using <code>f</code>.
 The parser succeeds if both the parsers succeed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithFst" class="def">teeWithFst</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWithFst" class="link">Source</a> <a href="#v:teeWithFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever the first parser ends.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:teeWithMin" class="def">teeWithMin</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x c <a href="src/Streamly.Internal.Data.Parser.html#teeWithMin" class="link">Source</a> <a href="#v:teeWithMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:teeWith" title="Streamly.Internal.Data.Parser">teeWith</a></code> but ends parsing and zips the results, if available,
 whenever any of the parsers ends or fails.</p><p><em>Unimplemented</em></p></div></div><a href="#g:7" id="g:7"><h2>Sequential Interleaving</h2></a><div class="top"><p class="src"><a id="v:deintercalate" class="def">deintercalate</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a y -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b z -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x (y, z) <a href="src/Streamly.Internal.Data.Parser.html#deintercalate" class="link">Source</a> <a href="#v:deintercalate" class="selflink">#</a></p><div class="doc"><p>Apply two parsers alternately to an input stream. The input stream is
 considered an interleaving of two patterns. The two parsers represent the
 two patterns.</p><p>This undoes a &quot;gintercalate&quot; of two streams.</p><p><em>Unimplemented</em></p></div></div><a href="#g:8" id="g:8"><h2>Sequential Alternative</h2></a><div class="top"><p class="src"><a id="v:alt" class="def">alt</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#alt" class="link">Source</a> <a href="#v:alt" class="selflink">#</a></p><div class="doc"><p>Sequential alternative. Apply the input to the first parser and return the
 result if the parser succeeds. If the first parser fails then backtrack and
 apply the same input to the second parser and return the result.</p><p>Note: This implementation is not lazy in the second argument. The following
 will fail:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.parse (PR.satisfy (&gt; 0) `PR.alt` undefined) $ S.fromList [1..10]
</code></strong></pre><p>Compare with <code>Alternative</code> instance method <code>&lt;|&gt;</code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code>Alternative</code> instance for small
 number (less than 8) of alternatives.</p><p><em>Internal</em></p></div></div><a href="#g:9" id="g:9"><h2>Parallel Alternatives</h2></a><div class="top"><p class="src"><a id="v:shortest" class="def">shortest</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#shortest" class="link">Source</a> <a href="#v:shortest" class="selflink">#</a></p><div class="doc"><p>Shortest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed least input i.e. take the shortest succeeding
 parse.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:longest" class="def">longest</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m x a <a href="src/Streamly.Internal.Data.Parser.html#longest" class="link">Source</a> <a href="#v:longest" class="selflink">#</a></p><div class="doc"><p>Longest alternative. Apply both parsers in parallel but choose the result
 from the one which consumed more input i.e. take the longest succeeding
 parse.</p><p><em>Internal</em></p></div></div><a href="#g:10" id="g:10"><h1>N-ary Combinators</h1></a><a href="#g:11" id="g:11"><h2>Sequential Collection</h2></a><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><p><code>sequence f t</code> collects sequential parses of parsers in the container <code>t</code>
 using the fold <code>f</code>. Fails if the input ends or any of the parsers fail.</p><p>This is same as <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Traversable.html#v:sequence" title="Data.Traversable">sequence</a></code> but more efficient.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> returning function on the result of a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code>.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance method <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#v:-62--62--61-" title="Control.Monad">&gt;&gt;=</a></code>. This implementation allows
 stream fusion but has quadratic complexity. This can fuse with other
 operations and can be much faster than <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance for small number
 (less than 8) of compositions.</p><p><em>Internal</em></p></div></div><a href="#g:12" id="g:12"><h2>Sequential Repetition</h2></a><div class="top"><p class="src"><a id="v:count" class="def">count</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#count" class="link">Source</a> <a href="#v:count" class="selflink">#</a></p><div class="doc"><p><code>count n f p</code> collects exactly <code>n</code> sequential parses of parser <code>p</code> using
 the fold <code>f</code>.  Fails if the input ends or the parser fails before <code>n</code>
 results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:countBetween" class="def">countBetween</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#countBetween" class="link">Source</a> <a href="#v:countBetween" class="selflink">#</a></p><div class="doc"><p><code>countBetween m n f p</code> collects between <code>m</code> and <code>n</code> sequential parses of
 parser <code>p</code> using the fold <code>f</code>. Stop after collecting <code>n</code> results. Fails if
 the input ends or the parser fails before <code>m</code> results are collected.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:manyP" class="def">manyP</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyP" class="link">Source</a> <a href="#v:manyP" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code> but uses a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> instead of a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> to collect the
 results. Parsing stops or fails if the collecting parser stops or fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:many" class="def">many</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#many" class="link">Source</a> <a href="#v:many" class="selflink">#</a></p><div class="doc"><p>Collect zero or more parses. Apply the parser repeatedly on the input
 stream, stop when the parser fails, accumulate zero or more parse results
 using the supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. This parser never fails, in case the first
 application of parser fails it returns an empty result.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:many" title="Control.Applicative">many</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:some" class="def">some</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#some" class="link">Source</a> <a href="#v:some" class="selflink">#</a></p><div class="doc"><p>Collect one or more parses. Apply the supplied parser repeatedly on the
 input stream and accumulate the parse results as long as the parser
 succeeds, stop when it fails.  This parser fails if not even one result is
 collected.</p><p>Compare with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:some" title="Control.Applicative">some</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:manyTillP" class="def">manyTillP</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyTillP" class="link">Source</a> <a href="#v:manyTillP" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:manyTill" title="Streamly.Internal.Data.Parser">manyTill</a></code> but uses a <code><a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a></code> to collect the results instead of a
 <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>.  Parsing stops or fails if the collecting parser stops or fails.</p><p>We can implemnent parsers like the following using <code><a href="Streamly-Internal-Data-Parser.html#v:manyTillP" title="Streamly.Internal.Data.Parser">manyTillP</a></code>:</p><pre>countBetweenTill m n f p = manyTillP (takeBetween m n f) p
</pre><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:manyTill" class="def">manyTill</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyTill" class="link">Source</a> <a href="#v:manyTill" class="selflink">#</a></p><div class="doc"><p><code>manyTill f collect test</code> tries the parser <code>test</code> on the input, if <code>test</code>
 fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds <code>test</code> is
 tried again and so on. The parser stops when <code>test</code> succeeds.  The output of
 <code>test</code> is discarded and the output of <code>collect</code> is accumulated by the
 supplied fold. The parser fails if <code>collect</code> fails.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:manyThen" class="def">manyThen</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a x -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#manyThen" class="link">Source</a> <a href="#v:manyThen" class="selflink">#</a></p><div class="doc"><p><code>manyThen f collect recover</code> repeats the parser <code>collect</code> on the input and
 collects the output in the supplied fold. If the the parser <code>collect</code> fails,
 parser <code>recover</code> is run until it stops and then we start repeating the
 parser <code>collect</code> again. The parser fails if the recovery parser fails.</p><p>For example, this can be used to find a key frame in a video stream after an
 error.</p><p><em>Unimplemented</em></p></div></div><a href="#g:13" id="g:13"><h2>Special cases</h2></a><div class="doc"><p>TODO: traditional implmentations of these may be of limited use. For
 example, consider parsing lines separated by <code>\r\n</code>. The main parser
 will have to detect and exclude the sequence <code>\r\n</code> anyway so that we
 can apply the &quot;sep&quot; parser.</p><p>We can instead implement these as special cases of deintercalate.</p><pre>, endBy
, sepBy
, sepEndBy
, beginBy
, sepBeginBy
, sepAroundBy
</pre></div><a href="#g:14" id="g:14"><h1>Distribution</h1></a><div class="doc"><p>A simple and stupid impl would be to just convert the stream to an
 array and give the array reference to all consumers. The array can be
 grown on demand by any consumer and truncated when nonbody needs it.</p></div><a href="#g:15" id="g:15"><h2>Distribute to collection</h2></a><a href="#g:16" id="g:16"><h2>Distribute to repetition</h2></a><a href="#g:17" id="g:17"><h2>Interleaved collection</h2></a><div class="doc"><ol><li>Round robin</li><li>Priority based</li></ol></div><div class="top"><p class="src"><a id="v:roundRobin" class="def">roundRobin</a> :: <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#roundRobin" class="link">Source</a> <a href="#v:roundRobin" class="selflink">#</a></p><div class="doc"><p>Apply a collection of parsers to an input stream in a round robin fashion.
 Each parser is applied until it stops and then we repeat starting with the
 the first parser again.</p><p><em>Unimplemented</em></p></div></div><a href="#g:18" id="g:18"><h2>Collection of Alternatives</h2></a><div class="doc"><p>Unimplemented</p><pre>, shortestN
, longestN
, fastestN -- first N successful in time
, choiceN  -- first N successful in position
</pre></div><div class="top"><p class="src"><a id="v:choice" class="def">choice</a> :: t (<a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b) -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#choice" class="link">Source</a> <a href="#v:choice" class="selflink">#</a></p><div class="doc"><p><code>choice parsers</code> applies the <code>parsers</code> in order and returns the first
 successful parse.</p><p>This is same as <code>asum</code> but more efficient.</p><p><em>Unimplemented</em></p></div></div><a href="#g:19" id="g:19"><h2>Repeated Alternatives</h2></a><div class="top"><p class="src"><a id="v:retryMaxTotal" class="def">retryMaxTotal</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#retryMaxTotal" class="link">Source</a> <a href="#v:retryMaxTotal" class="selflink">#</a></p><div class="doc"><p>Keep trying a parser up to a maximum of <code>n</code> failures.  When the parser
 fails the input consumed till now is dropped and the new instance is tried
 on the fresh input.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:retryMaxSuccessive" class="def">retryMaxSuccessive</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m b c -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a c <a href="src/Streamly.Internal.Data.Parser.html#retryMaxSuccessive" class="link">Source</a> <a href="#v:retryMaxSuccessive" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Parser.html#v:retryMaxTotal" title="Streamly.Internal.Data.Parser">retryMaxTotal</a></code> but aborts after <code>n</code> successive failures.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:retry" class="def">retry</a> :: <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser.html#t:Parser" title="Streamly.Internal.Data.Parser">Parser</a> m a b <a href="src/Streamly.Internal.Data.Parser.html#retry" class="link">Source</a> <a href="#v:retry" class="selflink">#</a></p><div class="doc"><p>Keep trying a parser until it succeeds.  When the parser fails the input
 consumed till now is dropped and the new instance is tried on the fresh
 input.</p><p><em>Unimplemented</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>