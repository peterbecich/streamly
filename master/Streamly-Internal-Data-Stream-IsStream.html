<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Streamly.Internal.Data.Stream.IsStream</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">streamly-master: Beautiful Streaming, Concurrent and Reactive Composition</span><ul class="links" id="page-menu"><li><a href="src/Streamly.Internal.Data.Stream.IsStream.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th valign="top">Copyright</th><td>(c) 2017 Composewell Technologies</td></tr><tr><th>License</th><td>BSD3</td></tr><tr><th>Maintainer</th><td>streamly@composewell.com</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>GHC</td></tr><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Streamly.Internal.Data.Stream.IsStream</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Stream Types</a><ul><li><a href="#g:2">Serial Streams</a></li><li><a href="#g:3">Speculative Streams</a></li><li><a href="#g:4">Asynchronous Streams</a></li><li><a href="#g:5">Zipping Streams</a></li></ul></li><li><a href="#g:6">Stream Type Adapters</a></li><li><a href="#g:7">Type Synonyms</a></li><li><a href="#g:8">Construction</a><ul><li><a href="#g:9">Primitives</a></li><li><a href="#g:10">From Values</a></li><li><a href="#g:11">Enumeration</a></li><li><a href="#g:12">Time Enumeration</a></li><li><a href="#g:13">From Generators</a></li><li><a href="#g:14">Iteration</a></li><li><a href="#g:15">Cyclic Elements</a></li><li><a href="#g:16">From Containers</a></li></ul></li><li><a href="#g:17">Elimination</a><ul><li><a href="#g:18">Deconstruction</a></li><li><a href="#g:19">Folding</a></li><li><a href="#g:20">Right Folds</a></li><li><a href="#g:21">Left Folds</a></li><li><a href="#g:22">Composable Left Folds</a></li><li><a href="#g:23">Concurrent Folds</a></li><li><a href="#g:24">Full Folds</a></li><li><a href="#g:25">Lazy Folds</a></li><li><a href="#g:26">Composable Left Folds</a></li><li><a href="#g:27">Partial Folds</a></li><li><a href="#g:28">Multi-Stream folds</a></li></ul></li><li><a href="#g:29">Transformation</a><ul><li><a href="#g:30">Mapping</a></li><li><a href="#g:31">Special Maps</a></li><li><a href="#g:32">Scanning</a></li><li><a href="#g:33">Left scans</a></li><li><a href="#g:34">Scan Using Fold</a></li><li><a href="#g:35">Concurrent Transformation</a></li><li><a href="#g:36">Filtering</a></li><li><a href="#g:37">Deleting Elements</a></li><li><a href="#g:38">Inserting Elements</a></li><li><a href="#g:39">Indexing</a></li><li><a href="#g:40">Reordering</a></li><li><a href="#g:41">Parsing</a></li><li><a href="#g:42">Trimming</a></li><li><a href="#g:43">Breaking</a></li><li><a href="#g:44">Searching</a></li><li><a href="#g:45">Splitting</a></li><li><a href="#g:46">Grouping</a></li><li><a href="#g:47">Group map</a></li></ul></li><li><a href="#g:48">Windowed Classification</a><ul><li><a href="#g:49">Tumbling Windows</a></li><li><a href="#g:50">Keep Alive Windows</a></li><li><a href="#g:51">Sliding Window Buffers</a></li></ul></li><li><a href="#g:52">Combining Streams</a><ul><li><a href="#g:53">Appending</a></li><li><a href="#g:54">Interleaving</a></li><li><a href="#g:55">Scheduling</a></li><li><a href="#g:56">Parallel</a></li><li><a href="#g:57">Merging</a></li><li><a href="#g:58">Zipping</a></li><li><a href="#g:59">Flattening a Container of Streams</a></li><li><a href="#g:60">Flattening a Stream of Streams</a></li><li><a href="#g:61">Flattening Using Unfolds</a></li><li><a href="#g:62">Flattening a Tree of Streams</a></li><li><a href="#g:63">Flattening a Graph of Streams</a></li><li><a href="#g:64">Inserting Streams in Streams</a></li></ul></li><li><a href="#g:65">Exceptions</a></li><li><a href="#g:66">Generalize Inner Monad</a></li><li><a href="#g:67">Transform Inner Monad</a></li><li><a href="#g:68">Maybe Streams</a></li><li><a href="#g:69">Either Streams</a></li><li><a href="#g:70">Concurrency Control</a></li><li><a href="#g:71">Rate Limiting</a></li><li><a href="#g:72">Diagnostics</a></li><li><a href="#g:73">Deprecated</a></li></ul></div></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This is an Internal module consisting of released, unreleased and
 unimplemented APIs. For stable and released APIs please see
 <a href="Streamly-Prelude.html">Streamly.Prelude</a> module. This module provides documentation only for the
 unreleased and unimplemented APIs. For documentation on released APIs please
 see <a href="Streamly-Prelude.html">Streamly.Prelude</a> module.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><span class="keyword">data</span> <a href="#t:SerialT">SerialT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Serial">Serial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:WSerialT">WSerialT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:WSerial">WSerial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:AheadT">AheadT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Ahead">Ahead</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:AsyncT">AsyncT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Async">Async</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:WAsyncT">WAsyncT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:WAsync">WAsync</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ParallelT">ParallelT</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:Parallel">Parallel</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><a href="#v:mkAsync">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:ZipSerialM">ZipSerialM</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:ZipSerial">ZipSerial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">data</span> <a href="#t:ZipAsyncM">ZipAsyncM</a> m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:ZipAsync">ZipAsync</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a></li><li class="src short"><span class="keyword">class</span> (<span class="keyword">forall</span> m a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (t m a), <span class="keyword">forall</span> m a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (t m a), <span class="keyword">forall</span> m. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m), <span class="keyword">forall</span> m. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (t m)) =&gt; <a href="#t:IsStream">IsStream</a> t</li><li class="src short"><a href="#v:serially">serially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:wSerially">wSerially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:asyncly">asyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:aheadly">aheadly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:wAsyncly">wAsyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:parallely">parallely</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; t m a</li><li class="src short"><a href="#v:zipSerially">zipSerially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; t m a</li><li class="src short"><a href="#v:zipAsyncly">zipAsyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; t m a</li><li class="src short"><a href="#v:adapt">adapt</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t1, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t2) =&gt; t1 m a -&gt; t2 m a</li><li class="src short"><span class="keyword">type</span> <a href="#t:MonadAsync">MonadAsync</a> m = (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m)</li><li class="src short"><a href="#v:nil">nil</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a</li><li class="src short"><a href="#v:nilM">nilM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a</li><li class="src short"><a href="#v:cons">cons</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:.:">(.:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:consM">consM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:-124-:">(|:)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:yield">yield</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:yieldM">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:repeat">repeat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:repeatM">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:replicate">replicate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; t m a</li><li class="src short"><a href="#v:replicateM">replicateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a</li><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a =&gt; <a href="#t:Enumerable">Enumerable</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:enumerateFrom">enumerateFrom</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromTo">enumerateFromTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromThen">enumerateFromThen</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a</li><li><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; a -&gt; t m a</li></ul></li><li class="src short"><a href="#v:enumerate">enumerate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> a) =&gt; t m a</li><li class="src short"><a href="#v:enumerateTo">enumerateTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> a) =&gt; a -&gt; t m a</li><li class="src short"><a href="#v:times">times</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>)</li><li class="src short"><a href="#v:absTimes">absTimes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a></li><li class="src short"><a href="#v:relTimes">relTimes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a></li><li class="src short"><a href="#v:durations">durations</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a></li><li class="src short"><a href="#v:ticks">ticks</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a> -&gt; t m ()</li><li class="src short"><a href="#v:timeout">timeout</a> :: <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> -&gt; t m ()</li><li class="src short"><a href="#v:currentTime">currentTime</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a></li><li class="src short"><a href="#v:unfoldr">unfoldr</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; t m a</li><li class="src short"><a href="#v:unfoldrM">unfoldrM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (b -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b))) -&gt; b -&gt; t m a</li><li class="src short"><a href="#v:unfold">unfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; a -&gt; t m b</li><li class="src short"><a href="#v:unfold0">unfold0</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b -&gt; t m b</li><li class="src short"><a href="#v:fromIndices">fromIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a) -&gt; t m a</li><li class="src short"><a href="#v:fromIndicesM">fromIndicesM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a) -&gt; t m a</li><li class="src short"><a href="#v:iterate">iterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a) -&gt; a -&gt; t m a</li><li class="src short"><a href="#v:iterateM">iterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m a) -&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:mfix">mfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (m a -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:fromList">fromList</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; [a] -&gt; t m a</li><li class="src short"><a href="#v:fromListM">fromListM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; [m a] -&gt; t m a</li><li class="src short"><a href="#v:fromFoldable">fromFoldable</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a</li><li class="src short"><a href="#v:fromFoldableM">fromFoldableM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f (m a) -&gt; t m a</li><li class="src short"><a href="#v:fromPrimIORef">fromPrimIORef</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-IORef-Prim.html#t:Prim" title="Streamly.Internal.Data.IORef.Prim">Prim</a> a) =&gt; <a href="Streamly-Internal-Data-IORef-Prim.html#t:IORef" title="Streamly.Internal.Data.IORef.Prim">IORef</a> a -&gt; t m a</li><li class="src short"><a href="#v:fromCallback">fromCallback</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; ((a -&gt; m ()) -&gt; m ()) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a</li><li class="src short"><a href="#v:uncons">uncons</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, t m a))</li><li class="src short"><a href="#v:tail">tail</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:init">init</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:foldrM">foldrM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldrS">foldrS</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldrT">foldrT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b</li><li class="src short"><a href="#v:foldr">foldr</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldl-39-">foldl'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldl1-39-">foldl1'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:foldlM-39-">foldlM'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:parse">parse</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:parseK">parseK</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:parseD">parseD</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldAsync">foldAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; m b</li><li class="src short"><a href="#v:-124--36-.">(|$.)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; m b</li><li class="src short"><a href="#v:-124--38-.">(|&amp;.)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; m b) -&gt; m b</li><li class="src short"><a href="#v:drain">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:last">last</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:length">length</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:sum">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:product">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:mconcat">mconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:maximumBy">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:maximum">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimumBy">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:minimum">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:the">the</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:toList">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m [a]</li><li class="src short"><a href="#v:toListRev">toListRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m [a]</li><li class="src short"><a href="#v:toPure">toPure</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:toPureRev">toPureRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:toStream">toStream</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:toStreamRev">toStreamRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</li><li class="src short"><a href="#v:drainN">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:drainWhile">drainWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:-33--33-">(!!)</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:head">head</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:headElse">headElse</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a</li><li class="src short"><a href="#v:findM">findM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:find">find</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:lookup">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m (a, b) -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:findIndex">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:elemIndex">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>)</li><li class="src short"><a href="#v:null">null</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:elem">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:notElem">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:all">all</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:any">any</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:and">and</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:or">or</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:eqBy">eqBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:cmpBy">cmpBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></li><li class="src short"><a href="#v:isPrefixOf">isPrefixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isSuffixOf">isSuffixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isInfixOf">isInfixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:isSubsequenceOf">isSubsequenceOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></li><li class="src short"><a href="#v:stripPrefix">stripPrefix</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a))</li><li class="src short"><a href="#v:stripSuffix">stripSuffix</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a))</li><li class="src short"><a href="#v:dropPrefix">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropInfix">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropSuffix">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:transform">transform</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:map">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:sequence">sequence</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a</li><li class="src short"><a href="#v:mapM">mapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:smapM">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mapM_">mapM_</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:trace">trace</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:trace_">trace_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tap">tap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapOffsetEvery">tapOffsetEvery</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapAsync">tapAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:tapRate">tapRate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m b) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:pollCounts">pollCounts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scanl-39-">scanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlM-39-">scanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanlMAfter-39-">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanl-39-">postscanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscanlM-39-">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanl-39-">prescanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:prescanlM-39-">prescanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:scanl1-39-">scanl1'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scanl1M-39-">scanl1M'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:scan">scan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:postscan">postscan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mkParallel">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:applyAsync">applyAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:-124--36-">(|$)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:-124--38-">(|&amp;)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:filter">filter</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:filterM">filterM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:deleteBy">deleteBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:uniq">uniq</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:insertBy">insertBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseM">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseM_">intersperseM_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperse">intersperse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffix">intersperseSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffix_">intersperseSuffix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interspersePrefix_">interspersePrefix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:intersperseSuffixBySpan">intersperseSuffixBySpan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:interjectSuffix">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delay">delay</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delayPost">delayPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:delayPre">delayPre</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:indexed">indexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:indexedR">indexedR</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a)</li><li class="src short"><a href="#v:timestamped">timestamped</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a)</li><li class="src short"><a href="#v:timeIndexed">timeIndexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a)</li><li class="src short"><a href="#v:reverse">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:reverse-39-">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parseMany">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyD">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseManyTill">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a x -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:parseIterate">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:take">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeByTime">takeByTime</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhile">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:takeWhileM">takeWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:drop">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropByTime">dropByTime</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhile">dropWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:dropWhileM">dropWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:chunksOf">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:chunksOf2">chunksOf2</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:arraysOf">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a)</li><li class="src short"><a href="#v:intervalsOf">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:findIndices">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:elemIndices">elemIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li><li class="src short"><a href="#v:splitOn">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffix">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffix">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:wordsBy">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSeq">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitOnSuffixSeq">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitBySeq">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitWithSuffixSeq">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:splitInnerBy">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:splitInnerBySuffix">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a)</li><li class="src short"><a href="#v:groups">groups</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsBy">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:groupsByRolling">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:rollingMapM">rollingMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:rollingMap">rollingMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:classifySessionsBy">classifySessionsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b) -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifySessionsOf">classifySessionsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b) -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:classifyKeepAliveSessions">classifyKeepAliveSessions</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b) -&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>) -&gt; t m (k, b)</li><li class="src short"><a href="#v:serial">serial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:append">append</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleave">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveMin">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveSuffix">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:interleaveInfix">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:wSerial">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialFst">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wSerialMin">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:ahead">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:async">async</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:wAsync">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:roundrobin">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b</li><li class="src short"><a href="#v:parallel">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelFst">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:parallelMin">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeBy">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeByM">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncBy">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:mergeAsyncByM">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:zipWith">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipWithM">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWith">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:zipAsyncWithM">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:concatFoldableWith">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMapFoldableWith">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b</li><li class="src short"><a href="#v:concatForFoldableWith">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b</li><li class="src short"><a href="#v:concat">concat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatM">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a</li><li class="src short"><a href="#v:concatMap">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMapM">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatMapWith">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatSmapMWith">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfold">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldInterleave">concatUnfoldInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:concatUnfoldRoundrobin">concatUnfoldRoundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:iterateMapWith">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:iterateSmapMWith">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:gintercalate">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:gintercalateSuffix">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalate">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:intercalateSuffix">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interpose">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:interposeSuffix">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c</li><li class="src short"><a href="#v:before">before</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:after_">after_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:after">after</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:bracket_">bracket_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:bracket">bracket</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a</li><li class="src short"><a href="#v:onException">onException</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:finally_">finally_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:finally">finally</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:handle">handle</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:hoist">hoist</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> n) =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> n a</li><li class="src short"><a href="#v:generally">generally</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m a</li><li class="src short"><a href="#v:liftInner">liftInner</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> tr, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (tr m)) =&gt; t m a -&gt; t (tr m) a</li><li class="src short"><a href="#v:usingReaderT">usingReaderT</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m r -&gt; (t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> r m) a -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> r m) a) -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:runReaderT">runReaderT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m s -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> s m) a -&gt; t m a</li><li class="src short"><a href="#v:evalStateT">evalStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a</li><li class="src short"><a href="#v:usingStateT">usingStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a</li><li class="src short"><a href="#v:runStateT">runStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m (s, a)</li><li class="src short"><a href="#v:catMaybes">catMaybes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; t m a</li><li class="src short"><a href="#v:mapMaybe">mapMaybe</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:mapMaybeM">mapMaybeM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:lefts">lefts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m a</li><li class="src short"><a href="#v:rights">rights</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m b</li><li class="src short"><a href="#v:iterateMapLeftsWith">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)</li><li class="src short"><a href="#v:maxThreads">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxBuffer">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a</li><li class="src short"><span class="keyword">data</span> <a href="#t:Rate">Rate</a> = <a href="#v:Rate">Rate</a> {<ul class="subs"><li><a href="#v:rateLow">rateLow</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateGoal">rateGoal</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateHigh">rateHigh</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></li><li><a href="#v:rateBuffer">rateBuffer</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></li></ul>}</li><li class="src short"><a href="#v:rate">rate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:avgRate">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:minRate">minRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:maxRate">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:constRate">constRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:inspectMode">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a</li><li class="src short"><a href="#v:once">once</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m a -&gt; t m a</li><li class="src short"><a href="#v:each">each</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a</li><li class="src short"><a href="#v:scanx">scanx</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b</li><li class="src short"><a href="#v:foldx">foldx</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldxM">foldxM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b</li><li class="src short"><a href="#v:foldr1">foldr1</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a)</li><li class="src short"><a href="#v:runStream">runStream</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:runN">runN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:runWhile">runWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m ()</li><li class="src short"><a href="#v:fromHandle">fromHandle</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a></li><li class="src short"><a href="#v:toHandle">toHandle</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m ()</li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Stream Types</h1></a><a href="#g:2" id="g:2"><h2>Serial Streams</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:SerialT" class="def">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#SerialT" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> behaves like a regular append
 operation.  Therefore, when <code>a &lt;&gt; b</code> is evaluated, stream <code>a</code> is evaluated
 first until it exhausts and then stream <code>b</code> is evaluated. In other words,
 the elements of stream <code>b</code> are appended to the elements of stream <code>a</code>. This
 operation can be used to fold an infinite lazy container of streams.</p><pre>import Streamly
import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S

main = (S.toList . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serially" title="Streamly.Internal.Data.Stream.IsStream">serially</a></code> $ (S.fromList [1,2]) &lt;&gt; (S.fromList [3,4])) &gt;&gt;= print
</pre><pre>[1,2,3,4]
</pre><p>The <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance runs the <em>monadic continuation</em> for each
 element of the stream, serially.</p><pre>main = S.drain . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serially" title="Streamly.Internal.Data.Stream.IsStream">serially</a></code> $ do
    x &lt;- return 1 &lt;&gt; return 2
    S.yieldM $ print x
</pre><pre>1
2
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> nests streams serially in a depth first manner.</p><pre>main = S.drain . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serially" title="Streamly.Internal.Data.Stream.IsStream">serially</a></code> $ do
    x &lt;- return 1 &lt;&gt; return 2
    y &lt;- return 3 &lt;&gt; return 4
    S.yieldM $ print (x, y)
</pre><pre>(1,3)
(1,4)
(2,3)
(2,4)
</pre><p>We call the monadic code being run for each element of the stream a monadic
 continuation. In imperative paradigm we can think of this composition as
 nested <code>for</code> loops and the monadic continuation is the body of the loop. The
 loop iterates for all elements of the stream.</p><p>Note that the behavior and semantics  of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>, including <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code>
 and <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instances are exactly like Haskell lists except that <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>
 can contain effectful actions while lists are pure.</p><p>In the code above, the <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serially" title="Streamly.Internal.Data.Stream.IsStream">serially</a></code> combinator can be omitted as the default
 stream type is <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:SerialT">Instances</h4><details id="i:SerialT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-145" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-173" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadState:4"></span> <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadReader:5"></span> <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Monad:6"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-183" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Applicative:8"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-238" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Foldable:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-262" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Foldable:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m m0 -&gt; m0 <a href="#v:fold" class="selflink">#</a></p><p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m0 <a href="#v:foldMap" class="selflink">#</a></p><p class="src"><a href="#v:foldMap-39-">foldMap'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m0 <a href="#v:foldMap-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; b <a href="#v:foldr" class="selflink">#</a></p><p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; b <a href="#v:foldr-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; b <a href="#v:foldl" class="selflink">#</a></p><p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; b <a href="#v:foldl-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:foldr1" class="selflink">#</a></p><p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:foldl1" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><p class="src"><a href="#v:null">null</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:null" class="selflink">#</a></p><p class="src"><a href="#v:length">length</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="#v:length" class="selflink">#</a></p><p class="src"><a href="#v:elem">elem</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:elem" class="selflink">#</a></p><p class="src"><a href="#v:maximum">maximum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:maximum" class="selflink">#</a></p><p class="src"><a href="#v:minimum">minimum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:minimum" class="selflink">#</a></p><p class="src"><a href="#v:sum">sum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:sum" class="selflink">#</a></p><p class="src"><a href="#v:product">product</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; a <a href="#v:product" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Traversable:10"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-263" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Traversable:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:traverse">traverse</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:traverse" class="selflink">#</a></p><p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (f a) -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequenceA" class="selflink">#</a></p><p class="src"><a href="#v:mapM">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:mapM" class="selflink">#</a></p><p class="src"><a href="#v:sequence">sequence</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (m a) -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequence" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadIO:11"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadIO:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:NFData1:12"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData1" title="Control.DeepSeq">NFData1</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-261" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:NFData1:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftRnf">liftRnf</a> :: (a -&gt; ()) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:liftRnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:MonadThrow:13"></span> <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-259" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:MonadThrow:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:IsList:14"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:IsList" title="GHC.Exts">IsList</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:IsList:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#t:Item" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromList">fromList</a> :: [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromList" class="selflink">#</a></p><p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromListN" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] <a href="#v:toList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Eq:15"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Eq:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Ord:16"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Ord:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:min" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Read:17"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Read:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readsPrec" class="selflink">#</a></p><p class="src"><a href="#v:readList">readList</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readList" class="selflink">#</a></p><p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readPrec" class="selflink">#</a></p><p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readListPrec" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Show:18"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Show:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:IsString:19"></span> a ~ <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:IsString:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromString">fromString</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromString" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Semigroup:20"></span> <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-145" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Semigroup:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Monoid:21"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-145" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Monoid:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:NFData:22"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> a =&gt; <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:NFData:22"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:rnf">rnf</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:rnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:SerialT:Item:23"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-260" class="link">Source</a> <a href="#t:SerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:SerialT:Item:23"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) = a</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Serial" class="def">Serial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Serial.html#Serial" class="link">Source</a> <a href="#t:Serial" class="selflink">#</a></p><div class="doc"><p>A serial IO stream of elements of type <code>a</code>. See <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> documentation
 for more details.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:WSerialT" class="def">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#WSerialT" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></code> interleaves the elements from the
 two streams.  Therefore, when <code>a &lt;&gt; b</code> is evaluated, stream <code>a</code> is evaluated
 first to produce the first element of the combined stream and then stream
 <code>b</code> is evaluated to produce the next element of the combined stream, and
 then we go back to evaluating stream <code>a</code> and so on. In other words, the
 elements of stream <code>a</code> are interleaved with the elements of stream <code>b</code>.</p><p>Note that evaluation of <code>a &lt;&gt; b &lt;&gt; c</code> does not schedule <code>a</code>, <code>b</code> and <code>c</code>
 with equal priority.  This expression is equivalent to <code>a &lt;&gt; (b &lt;&gt; c)</code>,
 therefore, it fairly interleaves <code>a</code> with the result of <code>b &lt;&gt; c</code>.  For
 example, <code>S.fromList [1,2] &lt;&gt; S.fromList [3,4] &lt;&gt; S.fromList [5,6] ::
 WSerialT Identity Int</code> would result in [1,3,2,5,4,6].  In other words, the
 leftmost stream gets the same scheduling priority as the rest of the
 streams taken together. The same is true for each subexpression on the right.</p><p>Note that this operation cannot be used to fold a container of infinite
 streams as the state that it needs to maintain is proportional to the number
 of streams.</p><p>The <code>W</code> in the name stands for <code>wide</code> or breadth wise scheduling in
 contrast to the depth wise scheduling behavior of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>.</p><pre>import Streamly
import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S

main = (S.toList . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wSerially" title="Streamly.Internal.Data.Stream.IsStream">wSerially</a></code> $ (S.fromList [1,2]) &lt;&gt; (S.fromList [3,4])) &gt;&gt;= print
</pre><pre>[1,3,2,4]
</pre><p>Similarly, the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance interleaves the iterations of the
 inner and the outer loop, nesting loops in a breadth first manner.</p><pre>main = S.drain . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wSerially" title="Streamly.Internal.Data.Stream.IsStream">wSerially</a></code> $ do
    x &lt;- return 1 &lt;&gt; return 2
    y &lt;- return 3 &lt;&gt; return 4
    S.yieldM $ print (x, y)
</pre><pre>(1,3)
(2,3)
(1,4)
(2,4)
</pre><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:WSerialT">Instances</h4><details id="i:WSerialT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-322" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-355" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadState:4"></span> <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadReader:5"></span> <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Monad:6"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-464" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Applicative:8"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-454" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Foldable:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-476" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Foldable:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m m0 -&gt; m0 <a href="#v:fold" class="selflink">#</a></p><p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; m0 <a href="#v:foldMap" class="selflink">#</a></p><p class="src"><a href="#v:foldMap-39-">foldMap'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; m0 <a href="#v:foldMap-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; b <a href="#v:foldr" class="selflink">#</a></p><p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; b <a href="#v:foldr-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; b <a href="#v:foldl" class="selflink">#</a></p><p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; b <a href="#v:foldl-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:foldr1" class="selflink">#</a></p><p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:foldl1" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><p class="src"><a href="#v:null">null</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:null" class="selflink">#</a></p><p class="src"><a href="#v:length">length</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="#v:length" class="selflink">#</a></p><p class="src"><a href="#v:elem">elem</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:elem" class="selflink">#</a></p><p class="src"><a href="#v:maximum">maximum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:maximum" class="selflink">#</a></p><p class="src"><a href="#v:minimum">minimum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:minimum" class="selflink">#</a></p><p class="src"><a href="#v:sum">sum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:sum" class="selflink">#</a></p><p class="src"><a href="#v:product">product</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; a <a href="#v:product" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Traversable:10"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-477" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Traversable:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:traverse">traverse</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:traverse" class="selflink">#</a></p><p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (f a) -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequenceA" class="selflink">#</a></p><p class="src"><a href="#v:mapM">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:mapM" class="selflink">#</a></p><p class="src"><a href="#v:sequence">sequence</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (m a) -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequence" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadIO:11"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadIO:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:NFData1:12"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData1" title="Control.DeepSeq">NFData1</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-475" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:NFData1:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftRnf">liftRnf</a> :: (a -&gt; ()) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:liftRnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:MonadThrow:13"></span> <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-473" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:MonadThrow:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:IsList:14"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:IsList" title="GHC.Exts">IsList</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:IsList:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#t:Item" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromList">fromList</a> :: [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromList" class="selflink">#</a></p><p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromListN" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] <a href="#v:toList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Eq:15"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Eq:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Ord:16"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Ord:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:min" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Read:17"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Read:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readsPrec" class="selflink">#</a></p><p class="src"><a href="#v:readList">readList</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readList" class="selflink">#</a></p><p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readPrec" class="selflink">#</a></p><p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readListPrec" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Show:18"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Show:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:IsString:19"></span> a ~ <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:IsString:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromString">fromString</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromString" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Semigroup:20"></span> <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-427" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Semigroup:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Monoid:21"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-444" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Monoid:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:NFData:22"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> a =&gt; <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:NFData:22"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:rnf">rnf</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:rnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WSerialT:Item:23"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-474" class="link">Source</a> <a href="#t:WSerialT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WSerialT:Item:23"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) = a</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:WSerial" class="def">WSerial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Serial.html#WSerial" class="link">Source</a> <a href="#t:WSerial" class="selflink">#</a></p><div class="doc"><p>An interleaving serial IO stream of elements of type <code>a</code>. See <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></code>
 documentation for more details.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:3" id="g:3"><h2>Speculative Streams</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:AheadT" class="def">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.Ahead.html#AheadT" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></code> appends two streams. The combined
 stream behaves like a single stream with the actions from the second stream
 appended to the first stream. The combined stream is evaluated in the
 speculative style.  This operation can be used to fold an infinite lazy
 container of streams.</p><pre>import <a href="Streamly-Prelude.html">Streamly.Prelude</a>
import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S
import Control.Concurrent

main = do
 xs &lt;- S.<code>toList</code> . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:aheadly" title="Streamly.Internal.Data.Stream.IsStream">aheadly</a></code> $ (p 1 |: p 2 |: nil) &lt;&gt; (p 3 |: p 4 |: nil)
 print xs
 where p n = threadDelay 1000000 &gt;&gt; return n
</pre><pre>[1,2,3,4]
</pre><p>Any exceptions generated by a constituent stream are propagated to the
 output stream.</p><p>The monad instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></code> may run each monadic continuation (bind)
 concurrently in a speculative manner, performing side effects in a partially
 ordered manner but producing the outputs in an ordered manner like
 <code>SerialT</code>.</p><pre>main = S.drain . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:aheadly" title="Streamly.Internal.Data.Stream.IsStream">aheadly</a></code> $ do
    n &lt;- return 3 &lt;&gt; return 2 &lt;&gt; return 1
    S.yieldM $ do
         threadDelay (n * 1000000)
         myThreadId &gt;&gt;= \tid -&gt; putStrLn (show tid ++ &quot;: Delay &quot; ++ show n)
</pre><pre>ThreadId 40: Delay 1
ThreadId 39: Delay 2
ThreadId 38: Delay 3
</pre><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:AheadT">Instances</h4><details id="i:AheadT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-671" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-689" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadState:4"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadReader:5"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:Monad:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-737" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:Applicative:8"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-731" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadIO:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadIO:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:MonadThrow:10"></span> (<a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-746" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:MonadThrow:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:Semigroup:11"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-704" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:Semigroup:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AheadT:Monoid:12"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-711" class="link">Source</a> <a href="#t:AheadT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AheadT:Monoid:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Ahead" class="def">Ahead</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#Ahead" class="link">Source</a> <a href="#t:Ahead" class="selflink">#</a></p><div class="doc"><p>A serial IO stream of elements of type <code>a</code> with concurrent lookahead.  See
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></code> documentation for more details.</p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:4" id="g:4"><h2>Asynchronous Streams</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:AsyncT" class="def">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.Async.html#AsyncT" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></p><div class="doc"><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation (<code>&lt;&gt;</code>) for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code> merges two streams
 concurrently with priority given to the first stream. In <code>s1 &lt;&gt; s2 &lt;&gt; s3
 ...</code> the streams s1, s2 and s3 are scheduled for execution in that order.
 Multiple scheduled streams may be executed concurrently and the elements
 generated by them are served to the consumer as and when they become
 available. This behavior is similar to the scheduling and execution behavior
 of actions in a single async stream.</p><p>Since only a finite number of streams are executed concurrently, this
 operation can be used to fold an infinite lazy container of streams.</p><pre>import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S
import Control.Concurrent

main = (S.toList . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:asyncly" title="Streamly.Internal.Data.Stream.IsStream">asyncly</a></code> $ (S.fromList [1,2]) &lt;&gt; (S.fromList [3,4])) &gt;&gt;= print
</pre><pre>[1,2,3,4]
</pre><p>Any exceptions generated by a constituent stream are propagated to the
 output stream. The output and exceptions from a single stream are guaranteed
 to arrive in the same order in the resulting stream as they were generated
 in the input stream. However, the relative ordering of elements from
 different streams in the resulting stream can vary depending on scheduling
 and generation delays.</p><p>Similarly, the monad instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code> <em>may</em> run each iteration
 concurrently based on demand.  More concurrent iterations are started only
 if the previous iterations are not able to produce enough output for the
 consumer.</p><pre>main = S.<code>drain</code> . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:asyncly" title="Streamly.Internal.Data.Stream.IsStream">asyncly</a></code> $ do
    n &lt;- return 3 &lt;&gt; return 2 &lt;&gt; return 1
    S.yieldM $ do
         threadDelay (n * 1000000)
         myThreadId &gt;&gt;= \tid -&gt; putStrLn (show tid ++ &quot;: Delay &quot; ++ show n)
</pre><pre>ThreadId 40: Delay 1
ThreadId 39: Delay 2
ThreadId 38: Delay 3
</pre><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:AsyncT">Instances</h4><details id="i:AsyncT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-720" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-738" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadState:4"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadReader:5"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:Monad:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-796" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:Applicative:8"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-777" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadIO:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadIO:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:MonadThrow:10"></span> (<a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-804" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:MonadThrow:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:Semigroup:11"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-755" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:Semigroup:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:AsyncT:Monoid:12"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-762" class="link">Source</a> <a href="#t:AsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:AsyncT:Monoid:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Async" class="def">Async</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Async.html#Async" class="link">Source</a> <a href="#t:Async" class="selflink">#</a></p><div class="doc"><p>A demand driven left biased parallely composing IO stream of elements of
 type <code>a</code>.  See <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code> documentation for more details.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:WAsyncT" class="def">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.Async.html#WAsyncT" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> is similar to <code>WSerialT</code> but with concurrent execution.
 The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation (<code>&lt;&gt;</code>) for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> merges two streams
 concurrently interleaving the actions from both the streams.  In <code>s1
 &lt;&gt; s2 &lt;&gt; s3 ...</code>, the individual actions from streams <code>s1</code>, <code>s2</code> and <code>s3</code>
 are scheduled for execution in a round-robin fashion.  Multiple scheduled
 actions may be executed concurrently, the results from concurrent executions
 are consumed in the order in which they become available.</p><p>The <code>W</code> in the name stands for <code>wide</code> or breadth wise scheduling in
 contrast to the depth wise scheduling behavior of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code>.</p><pre>import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S
import Control.Concurrent

main = (S.toList . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wAsyncly" title="Streamly.Internal.Data.Stream.IsStream">wAsyncly</a></code> . S.maxThreads 1 $ (S.fromList [1,2]) &lt;&gt; (S.fromList [3,4])) &gt;&gt;= print
</pre><pre>[1,3,2,4]
</pre><p>For this example, we are using <code>maxThreads 1</code> so that concurrent thread
 scheduling does not affect the results and make them unpredictable. Let's
 now take a more general example:</p><pre>main = (S.toList . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wAsyncly" title="Streamly.Internal.Data.Stream.IsStream">wAsyncly</a></code> . S.maxThreads 1 $ (S.fromList [1,2,3]) &lt;&gt; (S.fromList [4,5,6]) &lt;&gt; (S.fromList [7,8,9])) &gt;&gt;= print
</pre><pre>[1,4,2,7,5,3,8,6,9]
</pre><p>This is how the execution of the above stream proceeds:</p><ol><li>The scheduler queue is initialized with <code>[S.fromList [1,2,3],
 (S.fromList [4,5,6]) &lt;&gt; (S.fromList [7,8,9])]</code> assuming the head of the
 queue is represented by the  rightmost item.</li><li><code>S.fromList [1,2,3]</code> is executed, yielding the element <code>1</code> and putting
 <code>[2,3]</code> at the back of the scheduler queue. The scheduler queue now looks
 like <code>[(S.fromList [4,5,6]) &lt;&gt; (S.fromList [7,8,9]), S.fromList [2,3]]</code>.</li><li>Now <code>(S.fromList [4,5,6]) &lt;&gt; (S.fromList [7,8,9])</code> is picked up for
 execution, <code>S.fromList [7,8,9]</code> is added at the back of the queue and
 <code>S.fromList [4,5,6]</code> is executed, yielding the element <code>4</code> and adding
 <code>S.fromList [5,6]</code> at the back of the queue. The queue now looks like
 <code>[S.fromList [2,3], S.fromList [7,8,9], S.fromList [5,6]]</code>.</li><li>Note that the scheduler queue expands by one more stream component in
 every pass because one more <code>&lt;&gt;</code> is broken down into two components. At this
 point there are no more <code>&lt;&gt;</code> operations to be broken down further and the
 queue has reached its maximum size. Now these streams are scheduled in
 round-robin fashion yielding <code>[2,7,5,3,8,6,9]</code>.</li></ol><p>As we see above, in a right associated expression composed with <code>&lt;&gt;</code>, only
 one <code>&lt;&gt;</code> operation is broken down into two components in one execution,
 therefore, if we have <code>n</code> streams composed using <code>&lt;&gt;</code> it will take <code>n</code>
 scheduler passes to expand the whole expression.  By the time <code>n-th</code>
 component is added to the scheduler queue, the first component would have
 received <code>n</code> scheduler passes.</p><p>Since all streams get interleaved, this operation is not suitable for
 folding an infinite lazy container of infinite size streams.  However, if
 the streams are small, the streams on the left may get finished before more
 streams are added to the scheduler queue from the right side of the
 expression, so it may be possible to fold an infinite lazy container of
 streams. For example, if the streams are of size <code>n</code> then at most <code>n</code>
 streams would be in the scheduler queue at a time.</p><p>Note that <code>WSerialT</code> and <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> differ in their scheduling behavior,
 therefore the output of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> even with a single thread of execution is
 not the same as that of <code>WSerialT</code> See notes in <code>WSerialT</code> for details about
 its scheduling behavior.</p><p>Any exceptions generated by a constituent stream are propagated to the
 output stream. The output and exceptions from a single stream are guaranteed
 to arrive in the same order in the resulting stream as they were generated
 in the input stream. However, the relative ordering of elements from
 different streams in the resulting stream can vary depending on scheduling
 and generation delays.</p><p>Similarly, the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> runs <em>all</em> iterations fairly
 concurrently using a round robin scheduling.</p><pre>main = S.<code>drain</code> . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wAsyncly" title="Streamly.Internal.Data.Stream.IsStream">wAsyncly</a></code> $ do
    n &lt;- return 3 &lt;&gt; return 2 &lt;&gt; return 1
    S.yieldM $ do
         threadDelay (n * 1000000)
         myThreadId &gt;&gt;= \tid -&gt; putStrLn (show tid ++ &quot;: Delay &quot; ++ show n)
</pre><pre>ThreadId 40: Delay 1
ThreadId 39: Delay 2
ThreadId 38: Delay 3
</pre><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:WAsyncT">Instances</h4><details id="i:WAsyncT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-928" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-946" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadState:4"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadReader:5"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:Monad:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1002" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:Applicative:8"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-985" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadIO:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadIO:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:MonadThrow:10"></span> (<a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-1010" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:MonadThrow:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:Semigroup:11"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-961" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:Semigroup:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:WAsyncT:Monoid:12"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-968" class="link">Source</a> <a href="#t:WAsyncT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:WAsyncT:Monoid:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:WAsync" class="def">WAsync</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Async.html#WAsync" class="link">Source</a> <a href="#t:WAsync" class="selflink">#</a></p><div class="doc"><p>A round robin parallely composing IO stream of elements of type <code>a</code>.
 See <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code> documentation for more details.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ParallelT" class="def">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#ParallelT" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></p><div class="doc"><p>Async composition with strict concurrent execution of all streams.</p><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> executes both the streams
 concurrently without any delay or without waiting for the consumer demand
 and <em>merges</em> the results as they arrive. If the consumer does not consume
 the results, they are buffered upto a configured maximum, controlled by the
 <code>maxBuffer</code> primitive. If the buffer becomes full the concurrent tasks will
 block until there is space in the buffer.</p><p>Both <code>WAsyncT</code> and <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code>, evaluate the constituent streams fairly in a
 round robin fashion. The key difference is that <code>WAsyncT</code> might wait for the
 consumer demand before it executes the tasks whereas <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> starts
 executing all the tasks immediately without waiting for the consumer demand.
 For <code>WAsyncT</code> the <code>maxThreads</code> limit applies whereas for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> it does
 not apply. In other words, <code>WAsyncT</code> can be lazy whereas <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> is
 strict.</p><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> is useful for cases when the streams are required to be
 evaluated simultaneously irrespective of how the consumer consumes them e.g.
 when we want to race two tasks and want to start both strictly at the same
 time or if we have timers in the parallel tasks and our results depend on
 the timers being started at the same time. If we do not have such
 requirements then <code>AsyncT</code> or <code>AheadT</code> are recommended as they can be more
 efficient than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code>.</p><pre>main = (S.<code>toList</code> . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> $ (S.fromFoldable [1,2]) &lt;&gt; (S.fromFoldable [3,4])) &gt;&gt;= print
</pre><pre>[1,3,2,4]
</pre><p>When streams with more than one element are merged, it yields whichever
 stream yields first without any bias, unlike the <code>Async</code> style streams.</p><p>Any exceptions generated by a constituent stream are propagated to the
 output stream. The output and exceptions from a single stream are guaranteed
 to arrive in the same order in the resulting stream as they were generated
 in the input stream. However, the relative ordering of elements from
 different streams in the resulting stream can vary depending on scheduling
 and generation delays.</p><p>Similarly, the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a></code> instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> runs <em>all</em> iterations
 of the loop concurrently.</p><pre>import qualified <a href="Streamly-Prelude.html">Streamly.Prelude</a> as S
import Control.Concurrent

main = S.<code>drain</code> . S.<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> $ do
    n &lt;- return 3 &lt;&gt; return 2 &lt;&gt; return 1
    S.yieldM $ do
         threadDelay (n * 1000000)
         myThreadId &gt;&gt;= \tid -&gt; putStrLn (show tid ++ &quot;: Delay &quot; ++ show n)
</pre><pre>ThreadId 40: Delay 1
ThreadId 39: Delay 2
ThreadId 38: Delay 3
</pre><p>Note that parallel composition can only combine a finite number of
 streams as it needs to retain state for each unfinished stream.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.7.0 (maxBuffer applies to ParallelT streams)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ParallelT">Instances</h4><details id="i:ParallelT" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadTrans:1"></span> <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-500" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadTrans:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:lift">lift</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:lift" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-518" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadBase:3"></span> (<a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/transformers-base-0.4.5.2/docs/Control-Monad-Base.html#t:MonadBase" title="Control.Monad.Base">MonadBase</a> b (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadBase:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftBase">liftBase</a> :: b &#945; -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m &#945; <a href="#v:liftBase" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadState:4"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html#t:MonadState" title="Control.Monad.State.Class">MonadState</a> s (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadState:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:get">get</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m s <a href="#v:get" class="selflink">#</a></p><p class="src"><a href="#v:put">put</a> :: s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m () <a href="#v:put" class="selflink">#</a></p><p class="src"><a href="#v:state">state</a> :: (s -&gt; (a, s)) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:state" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadReader:5"></span> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader" title="Control.Monad.Reader.Class">MonadReader</a> r (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadReader:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:ask">ask</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m r <a href="#v:ask" class="selflink">#</a></p><p class="src"><a href="#v:local">local</a> :: (r -&gt; r) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:local" class="selflink">#</a></p><p class="src"><a href="#v:reader">reader</a> :: (r -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:reader" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:Monad:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-576" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:Monad:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-62--62--61-">(&gt;&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; (a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b <a href="#v:-62--62--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62--62-">(&gt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b <a href="#v:-62--62-" class="selflink">#</a></p><p class="src"><a href="#v:return">return</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:return" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:Functor:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:Functor:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:Applicative:8"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-561" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:Applicative:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadIO:9"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadIO:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftIO">liftIO</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:liftIO" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:MonadThrow:10"></span> (<a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-584" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:MonadThrow:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:throwM">throwM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e =&gt; e -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:throwM" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:Semigroup:11"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-539" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:Semigroup:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ParallelT:Monoid:12"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-546" class="link">Source</a> <a href="#t:ParallelT" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ParallelT:Monoid:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:Parallel" class="def">Parallel</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#Parallel" class="link">Source</a> <a href="#t:Parallel" class="selflink">#</a></p><div class="doc"><p>A parallely composing IO stream of elements of type <code>a</code>.
 See <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code> documentation for more details.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:mkAsync" class="def">mkAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Async.html#mkAsync" class="link">Source</a> <a href="#v:mkAsync" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it terminates if the buffer is full and a worker thread is
 kicked off again to evaluate the remaining stream when there is space in the
 buffer.  The consumer consumes the stream lazily from the buffer.</p><p><em>Internal</em></p></div></div><a href="#g:5" id="g:5"><h2>Zipping Streams</h2></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ZipSerialM" class="def">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.Zip.html#ZipSerialM" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></p><div class="doc"><p>The applicative instance of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a></code> zips a number of streams serially
 i.e. it produces one element from each stream serially and then zips all
 those elements.</p><pre>main = (toList . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:zipSerially" title="Streamly.Internal.Data.Stream.IsStream">zipSerially</a></code> $ (,,) &lt;$&gt; s1 &lt;*&gt; s2 &lt;*&gt; s3) &gt;&gt;= print
    where s1 = fromFoldable [1, 2]
          s2 = fromFoldable [3, 4]
          s3 = fromFoldable [5, 6]
</pre><pre>[(1,3,5),(2,4,6)]
</pre><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> instance of this type works the same way as that of
 <code>SerialT</code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ZipSerialM">Instances</h4><details id="i:ZipSerialM" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:IsStream:1"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a></span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-169" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:IsStream:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-186" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Applicative:3"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-190" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Foldable:4"></span> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-195" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Foldable:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fold">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m m0 -&gt; m0 <a href="#v:fold" class="selflink">#</a></p><p class="src"><a href="#v:foldMap">foldMap</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; m0 <a href="#v:foldMap" class="selflink">#</a></p><p class="src"><a href="#v:foldMap-39-">foldMap'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> m0 =&gt; (a -&gt; m0) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; m0 <a href="#v:foldMap-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; b <a href="#v:foldr" class="selflink">#</a></p><p class="src"><a href="#v:foldr-39-">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; b <a href="#v:foldr-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldl">foldl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; b <a href="#v:foldl" class="selflink">#</a></p><p class="src"><a href="#v:foldl-39-">foldl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; b <a href="#v:foldl-39-" class="selflink">#</a></p><p class="src"><a href="#v:foldr1">foldr1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:foldr1" class="selflink">#</a></p><p class="src"><a href="#v:foldl1">foldl1</a> :: (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:foldl1" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; [a] <a href="#v:toList" class="selflink">#</a></p><p class="src"><a href="#v:null">null</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:null" class="selflink">#</a></p><p class="src"><a href="#v:length">length</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="#v:length" class="selflink">#</a></p><p class="src"><a href="#v:elem">elem</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:elem" class="selflink">#</a></p><p class="src"><a href="#v:maximum">maximum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:maximum" class="selflink">#</a></p><p class="src"><a href="#v:minimum">minimum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:minimum" class="selflink">#</a></p><p class="src"><a href="#v:sum">sum</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:sum" class="selflink">#</a></p><p class="src"><a href="#v:product">product</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; a <a href="#v:product" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Traversable:5"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Traversable.html#t:Traversable" title="Data.Traversable">Traversable</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-196" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Traversable:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:traverse">traverse</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; (a -&gt; f b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:traverse" class="selflink">#</a></p><p class="src"><a href="#v:sequenceA">sequenceA</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> f =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (f a) -&gt; f (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequenceA" class="selflink">#</a></p><p class="src"><a href="#v:mapM">mapM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> b) <a href="#v:mapM" class="selflink">#</a></p><p class="src"><a href="#v:sequence">sequence</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> (m a) -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:sequence" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:NFData1:6"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData1" title="Control.DeepSeq">NFData1</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a>)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-184" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:NFData1:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:liftRnf">liftRnf</a> :: (a -&gt; ()) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:liftRnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:IsList:7"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:IsList" title="GHC.Exts">IsList</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:IsList:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#t:Item" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromList">fromList</a> :: [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromList" class="selflink">#</a></p><p class="src"><a href="#v:fromListN">fromListN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromListN" class="selflink">#</a></p><p class="src"><a href="#v:toList">toList</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; [<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)] <a href="#v:toList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Eq:8"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Eq:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-61--61-">(==)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-61--61-" class="selflink">#</a></p><p class="src"><a href="#v:-47--61-">(/=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-47--61-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Ord:9"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Ord:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:compare">compare</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="#v:compare" class="selflink">#</a></p><p class="src"><a href="#v:-60-">(&lt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60-" class="selflink">#</a></p><p class="src"><a href="#v:-60--61-">(&lt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-60--61-" class="selflink">#</a></p><p class="src"><a href="#v:-62-">(&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62-" class="selflink">#</a></p><p class="src"><a href="#v:-62--61-">(&gt;=)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="#v:-62--61-" class="selflink">#</a></p><p class="src"><a href="#v:max">max</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:max" class="selflink">#</a></p><p class="src"><a href="#v:min">min</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:min" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Read:10"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Read.html#t:Read" title="Text.Read">Read</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Read:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:readsPrec">readsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readsPrec" class="selflink">#</a></p><p class="src"><a href="#v:readList">readList</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadP.html#t:ReadS" title="Text.ParserCombinators.ReadP">ReadS</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readList" class="selflink">#</a></p><p class="src"><a href="#v:readPrec">readPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="#v:readPrec" class="selflink">#</a></p><p class="src"><a href="#v:readListPrec">readListPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-ParserCombinators-ReadPrec.html#t:ReadPrec" title="Text.ParserCombinators.ReadPrec">ReadPrec</a> [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] <a href="#v:readListPrec" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Show:11"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> a =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:Show" title="Text.Show">Show</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Show:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a] -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Text-Show.html#t:ShowS" title="Text.Show">ShowS</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:IsString:12"></span> a ~ <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:IsString" title="Data.String">IsString</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:IsString:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fromString">fromString</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a <a href="#v:fromString" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Semigroup:13"></span> <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-137" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Semigroup:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Monoid:14"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-137" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Monoid:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:NFData:15"></span> <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> a =&gt; <a href="https://hackage.haskell.org/package/deepseq-1.4.4.0/docs/Control-DeepSeq.html#t:NFData" title="Control.DeepSeq">NFData</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:NFData:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:rnf">rnf</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; () <a href="#v:rnf" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipSerialM:Item:16"></span> <span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-183" class="link">Source</a> <a href="#t:ZipSerialM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipSerialM:Item:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="src"><span class="keyword">type</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Exts.html#t:Item" title="GHC.Exts">Item</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) = a</div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ZipSerial" class="def">ZipSerial</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Zip.html#ZipSerial" class="link">Source</a> <a href="#t:ZipSerial" class="selflink">#</a></p><div class="doc"><p>An IO stream whose applicative instance zips streams serially.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:ZipAsyncM" class="def">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.Zip.html#ZipAsyncM" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a></code> but zips in parallel, it generates all the elements to
 be zipped concurrently.</p><pre>main = (toList . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:zipAsyncly" title="Streamly.Internal.Data.Stream.IsStream">zipAsyncly</a></code> $ (,,) &lt;$&gt; s1 &lt;*&gt; s2 &lt;*&gt; s3) &gt;&gt;= print
    where s1 = fromFoldable [1, 2]
          s2 = fromFoldable [3, 4]
          s3 = fromFoldable [5, 6]
</pre><pre>[(1,3,5),(2,4,6)]
</pre><p>The <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> instance of this type works the same way as that of
 <code>SerialT</code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:ZipAsyncM">Instances</h4><details id="i:ZipAsyncM" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipAsyncM:IsStream:1"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a></span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-249" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipAsyncM:IsStream:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipAsyncM:Functor:2"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-263" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipAsyncM:Functor:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:fmap">fmap</a> :: (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b <a href="#v:fmap" class="selflink">#</a></p><p class="src"><a href="#v:-60--36-">(&lt;$)</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:-60--36-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipAsyncM:Applicative:3"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-267" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipAsyncM:Applicative:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:pure">pure</a> :: a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:pure" class="selflink">#</a></p><p class="src"><a href="#v:-60--42--62-">(&lt;*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m (a -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b <a href="#v:-60--42--62-" class="selflink">#</a></p><p class="src"><a href="#v:liftA2">liftA2</a> :: (a -&gt; b -&gt; c) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m c <a href="#v:liftA2" class="selflink">#</a></p><p class="src"><a href="#v:-42--62-">(*&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b <a href="#v:-42--62-" class="selflink">#</a></p><p class="src"><a href="#v:-60--42-">(&lt;*)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:-60--42-" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipAsyncM:Semigroup:4"></span> <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-222" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipAsyncM:Semigroup:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:-60--62-">(&lt;&gt;)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:-60--62-" class="selflink">#</a></p><p class="src"><a href="#v:sconcat">sconcat</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-List-NonEmpty.html#t:NonEmpty" title="Data.List.NonEmpty">NonEmpty</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:sconcat" class="selflink">#</a></p><p class="src"><a href="#v:stimes">stimes</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> b =&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:stimes" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:ZipAsyncM:Monoid:5"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a)</span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-222" class="link">Source</a> <a href="#t:ZipAsyncM" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:ZipAsyncM:Monoid:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:mempty">mempty</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:mempty" class="selflink">#</a></p><p class="src"><a href="#v:mappend">mappend</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:mappend" class="selflink">#</a></p><p class="src"><a href="#v:mconcat">mconcat</a> :: [<a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a] -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="#v:mconcat" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:ZipAsync" class="def">ZipAsync</a> = <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> <a href="src/Streamly.Internal.Data.Stream.Zip.html#ZipAsync" class="link">Source</a> <a href="#t:ZipAsync" class="selflink">#</a></p><div class="doc"><p>An IO stream whose applicative instance zips streams wAsyncly.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:6" id="g:6"><h1>Stream Type Adapters</h1></a><div class="top"><p class="src"><span class="keyword">class</span> (<span class="keyword">forall</span> m a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a> (t m a), <span class="keyword">forall</span> m a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (t m a), <span class="keyword">forall</span> m. <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m), <span class="keyword">forall</span> m. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#t:Applicative" title="Control.Applicative">Applicative</a> (t m)) =&gt; <a id="t:IsStream" class="def">IsStream</a> t <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#IsStream" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></p><div class="doc"><p>Class of types that can represent a stream of elements of some type <code>a</code> in
 some monad <code>m</code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Streamly-Internal-Data-Stream-StreamK-Type.html#v:toStream" title="Streamly.Internal.Data.Stream.StreamK.Type">toStream</a>, <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#v:fromStream" title="Streamly.Internal.Data.Stream.StreamK.Type">fromStream</a>, <a href="Streamly-Internal-Data-Stream-IsStream.html#v:consM" title="Streamly.Internal.Data.Stream.IsStream">consM</a>, <a href="Streamly-Internal-Data-Stream-IsStream.html#v:-124-:" title="Streamly.Internal.Data.Stream.IsStream">(|:)</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:IsStream">Instances</h4><details id="i:IsStream" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:1"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#line-427" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-StreamK-Type.html">Streamly.Internal.Data.Stream.StreamK.Type</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a></span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-249" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:3"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a></span> <a href="src/Streamly.Internal.Data.Stream.Zip.html#line-169" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Zip.html">Streamly.Internal.Data.Stream.Zip</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:4"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-355" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:5"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#line-173" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Serial.html">Streamly.Internal.Data.Stream.Serial</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#line-518" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Parallel.html">Streamly.Internal.Data.Stream.Parallel</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:7"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-946" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:8"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#line-738" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Async.html">Streamly.Internal.Data.Stream.Async</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:IsStream:IsStream:9"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#line-689" class="link">Source</a> <a href="#t:IsStream" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:IsStream:IsStream:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Ahead.html">Streamly.Internal.Data.Stream.Ahead</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:toStream">toStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><p class="src"><a href="#v:fromStream">fromStream</a> :: <span class="keyword">forall</span> (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>) a. <a href="Streamly-Internal-Data-Stream-StreamK-Type.html#t:Stream" title="Streamly.Internal.Data.Stream.StreamK.Type">Stream</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#fromStream" class="link">Source</a> <a href="#v:fromStream" class="selflink">#</a></p><p class="src"><a href="#v:consM">consM</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><p class="src"><a href="#v:-124-:">(|:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:serially" class="def">serially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#serially" class="link">Source</a> <a href="#v:serially" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerially" class="def">wSerially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerially" class="link">Source</a> <a href="#v:wSerially" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:asyncly" class="def">asyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Async.html#asyncly" class="link">Source</a> <a href="#v:asyncly" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code>.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:aheadly" class="def">aheadly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Ahead.html#aheadly" class="link">Source</a> <a href="#v:aheadly" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></code>.</p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wAsyncly" class="def">wAsyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Async.html#wAsyncly" class="link">Source</a> <a href="#v:wAsyncly" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallely" class="def">parallely</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallely" class="link">Source</a> <a href="#v:parallely" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code>.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipSerially" class="def">zipSerially</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipSerially" class="link">Source</a> <a href="#v:zipSerially" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipSerialM" title="Streamly.Internal.Data.Stream.IsStream">ZipSerialM</a></code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncly" class="def">zipAsyncly</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a> m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipAsyncly" class="link">Source</a> <a href="#v:zipAsyncly" class="selflink">#</a></p><div class="doc"><p>Fix the type of a polymorphic stream as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ZipAsyncM" title="Streamly.Internal.Data.Stream.IsStream">ZipAsyncM</a></code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:adapt" class="def">adapt</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t1, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t2) =&gt; t1 m a -&gt; t2 m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#adapt" class="link">Source</a> <a href="#v:adapt" class="selflink">#</a></p><div class="doc"><p>Adapt any specific stream type to any other specific stream type.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:7" id="g:7"><h1>Type Synonyms</h1></a><div class="top"><p class="src"><span class="keyword">type</span> <a id="t:MonadAsync" class="def">MonadAsync</a> m = (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) <a href="src/Streamly.Internal.Data.SVar.html#MonadAsync" class="link">Source</a> <a href="#t:MonadAsync" class="selflink">#</a></p><div class="doc"><p>A monad that can perform concurrent or parallel IO operations. Streams
 that can be composed concurrently require the underlying monad to be
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a></code>.</p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:8" id="g:8"><h1>Construction</h1></a><a href="#g:9" id="g:9"><h2>Primitives</h2></a><div class="top"><p class="src"><a id="v:nil" class="def">nil</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#nil" class="link">Source</a> <a href="#v:nil" class="selflink">#</a></p><div class="doc"><p>An empty stream.</p><pre>&gt; toList nil
[]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:nilM" class="def">nilM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#nilM" class="link">Source</a> <a href="#v:nilM" class="selflink">#</a></p><div class="doc"><p>An empty stream producing a side effect.</p><pre>&gt; toList (nilM (print &quot;nil&quot;))
&quot;nil&quot;
[]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:cons" class="def">cons</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#cons" class="link">Source</a> <a href="#v:cons" class="selflink">#</a></p><div class="doc"><p>Construct a stream by adding a pure value at the head of an existing
 stream. For serial streams this is the same as <code>(return a) `consM` r</code> but
 more efficient. For concurrent streams this is not concurrent whereas
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:consM" title="Streamly.Internal.Data.Stream.IsStream">consM</a></code> is concurrent. For example:</p><pre>&gt; toList $ 1 `cons` 2 `cons` 3 `cons` nil
[1,2,3]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:.:" class="def">(.:)</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#.%3A" class="link">Source</a> <a href="#v:.:" class="selflink">#</a></p><div class="doc"><p>Operator equivalent of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:cons" title="Streamly.Internal.Data.Stream.IsStream">cons</a></code>.</p><pre>&gt; toList $ 1 .: 2 .: 3 .: nil
[1,2,3]
</pre><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:consM" class="def">consM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#consM" class="link">Source</a> <a href="#v:consM" class="selflink">#</a></p><div class="doc"><p>Constructs a stream by adding a monadic action at the head of an
 existing stream. For example:</p><pre>&gt; toList $ getLine `consM` getLine `consM` nil
hello
world
[&quot;hello&quot;,&quot;world&quot;]
</pre><p><em>Concurrent (do not use <code>parallely</code> to construct infinite streams)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:-124-:" class="def">(|:)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 5</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#%7C%3A" class="link">Source</a> <a href="#v:-124-:" class="selflink">#</a></p><div class="doc"><p>Operator equivalent of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:consM" title="Streamly.Internal.Data.Stream.IsStream">consM</a></code>. We can read it as &quot;<code>parallel colon</code>&quot;
 to remember that <code>|</code> comes before <code>:</code>.</p><pre>&gt; toList $ getLine |: getLine |: nil
hello
world
[&quot;hello&quot;,&quot;world&quot;]
</pre><pre>let delay = threadDelay 1000000 &gt;&gt; print 1
drain $ serially  $ delay |: delay |: delay |: nil
drain $ parallely $ delay |: delay |: delay |: nil
</pre><p><em>Concurrent (do not use <code>parallely</code> to construct infinite streams)</em></p><p><em>Since: 0.2.0</em></p></div></div><a href="#g:10" id="g:10"><h2>From Values</h2></a><div class="top"><p class="src"><a id="v:yield" class="def">yield</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#yield" class="link">Source</a> <a href="#v:yield" class="selflink">#</a></p><div class="doc"><pre>yield a = a `cons` nil
</pre><p>Create a singleton stream from a pure value.</p><p>The following holds in monadic streams, but not in Zip streams:</p><pre>yield = pure
yield = yieldM . pure
</pre><p>In Zip applicative streams <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream">yield</a></code> is not the same as <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> because in that
 case <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is equivalent to <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:repeat" title="Streamly.Internal.Data.Stream.IsStream">repeat</a></code> instead. <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream">yield</a></code> and <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> are
 equally efficient, in other cases <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream">yield</a></code> may be slightly more efficient
 than the other equivalent definitions.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:yieldM" class="def">yieldM</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#yieldM" class="link">Source</a> <a href="#v:yieldM" class="selflink">#</a></p><div class="doc"><pre>yieldM m = m `consM` nil
</pre><p>Create a singleton stream from a monadic action.</p><pre>&gt; toList $ yieldM getLine
hello
[&quot;hello&quot;]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:repeat" class="def">repeat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#repeat" class="link">Source</a> <a href="#v:repeat" class="selflink">#</a></p><div class="doc"><p>Generate an infinite stream by repeating a pure value.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:repeatM" class="def">repeatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#repeatM" class="link">Source</a> <a href="#v:repeatM" class="selflink">#</a></p><div class="doc"><pre>repeatM = fix . consM
repeatM = cycle1 . yieldM
</pre><p>Generate a stream by repeatedly executing a monadic action forever.</p><pre>drain $ serially $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.take 10 $ S.repeatM $ (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent, infinite (do not use with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code>)</em></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:replicate" class="def">replicate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#replicate" class="link">Source</a> <a href="#v:replicate" class="selflink">#</a></p><div class="doc"><pre>replicate = take n . repeat
</pre><p>Generate a stream of length <code>n</code> by repeating a value <code>n</code> times.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:replicateM" class="def">replicateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#replicateM" class="link">Source</a> <a href="#v:replicateM" class="selflink">#</a></p><div class="doc"><pre>replicateM = take n . repeatM
</pre><p>Generate a stream by performing a monadic action <code>n</code> times. Same as:</p><pre>drain $ serially $ S.replicateM 10 $ (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.replicateM 10 $ (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.1.1</em></p></div></div><a href="#g:11" id="g:11"><h2>Enumeration</h2></a><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a =&gt; <a id="t:Enumerable" class="def">Enumerable</a> a <span class="keyword">where</span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#Enumerable" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></p><div class="doc"><p>Types that can be enumerated as a stream. The operations in this type
 class are equivalent to those in the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a></code> type class, except that these
 generate a stream instead of a list. Use the functions in
 <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a> module to define new instances.</p><p><em>Since: 0.6.0</em></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:enumerateFrom" class="def">enumerateFrom</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><div class="doc"><p><code>enumerateFrom from</code> generates a stream starting with the element
 <code>from</code>, enumerating up to <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code> when the type is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> or
 generating an infinite stream when the type is not <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code>.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFrom (0 :: Int)
[0,1,2,3]
</pre><p>For <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> types, enumeration is numerically stable. However, no
 overflow or underflow checks are performed.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFrom 1.1
[1.1,2.1,3.1,4.1]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromTo" class="def">enumerateFromTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><div class="doc"><p>Generate a finite stream starting with the element <code>from</code>, enumerating
 the type up to the value <code>to</code>. If <code>to</code> is smaller than <code>from</code> then an
 empty stream is returned.</p><pre>&gt; S.toList $ S.enumerateFromTo 0 4
[0,1,2,3,4]
</pre><p>For <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Fractional" title="Prelude">Fractional</a></code> types, the last element is equal to the specified <code>to</code>
 value after rounding to the nearest integral value.</p><pre>&gt; S.toList $ S.enumerateFromTo 1.1 4
[1.1,2.1,3.1,4.1]
&gt; S.toList $ S.enumerateFromTo 1.1 4.6
[1.1,2.1,3.1,4.1,5.1]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromThen" class="def">enumerateFromThen</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><div class="doc"><p><code>enumerateFromThen from then</code> generates a stream whose first element
 is <code>from</code>, the second element is <code>then</code> and the successive elements are
 in increments of <code>then - from</code>.  Enumeration can occur downwards or
 upwards depending on whether <code>then</code> comes before or after <code>from</code>. For
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> types the stream ends when <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code> is reached, for
 unbounded types it keeps enumerating infinitely.</p><pre>&gt; S.toList $ S.take 4 $ S.enumerateFromThen 0 2
[0,2,4,6]
&gt; S.toList $ S.take 4 $ S.enumerateFromThen 0 (-2)
[0,-2,-4,-6]
</pre><p><em>Since: 0.6.0</em></p></div><p class="src"><a id="v:enumerateFromThenTo" class="def">enumerateFromThenTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; a -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p><div class="doc"><p><code>enumerateFromThenTo from then to</code> generates a finite stream whose
 first element is <code>from</code>, the second element is <code>then</code> and the successive
 elements are in increments of <code>then - from</code> up to <code>to</code>. Enumeration can
 occur downwards or upwards depending on whether <code>then</code> comes before or
 after <code>from</code>.</p><pre>&gt; S.toList $ S.enumerateFromThenTo 0 2 6
[0,2,4,6]
&gt; S.toList $ S.enumerateFromThenTo 0 (-2) (-6)
[0,-2,-4,-6]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Enumerable">Instances</h4><details id="i:Enumerable" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:1"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-464" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:2"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-466" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:2"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Char.html#t:Char" title="Data.Char">Char</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:3"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-519" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:3"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:4"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-518" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:4"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Float" title="Prelude">Float</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:5"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-480" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:5"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:6"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-481" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:6"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int8" title="Data.Int">Int8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:7"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-482" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:7"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int16" title="Data.Int">Int16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:8"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-483" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:8"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int32" title="Data.Int">Int32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:9"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-484" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:9"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int64" title="Data.Int">Int64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:10"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-504" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:10"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integer" title="Prelude">Integer</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:11"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-505" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:11"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-Natural.html#t:Natural" title="GHC.Natural">Natural</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:12"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-465" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:12"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:13"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-485" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:13"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word" title="Data.Word">Word</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:14"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-486" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:14"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word8" title="Data.Word">Word8</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:15"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-487" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:15"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word16" title="Data.Word">Word16</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:16"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-488" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:16"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word32" title="Data.Word">Word32</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:17"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a></span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-489" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:17"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Word.html#t:Word64" title="Data.Word">Word64</a> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:18"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> ()</span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-463" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:18"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; () -&gt; () -&gt; () -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:19"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Integral" title="Prelude">Integral</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-521" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:19"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ratio.html#t:Ratio" title="Data.Ratio">Ratio</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:20"></span> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-523" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:20"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:Enumerable:Enumerable:21"></span> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:HasResolution" title="Data.Fixed">HasResolution</a> a =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a)</span> <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#line-520" class="link">Source</a> <a href="#t:Enumerable" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:Enumerable:Enumerable:21"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Streamly-Internal-Data-Stream-Enumeration.html">Streamly.Internal.Data.Stream.Enumeration</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:enumerateFrom">enumerateFrom</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFrom" class="link">Source</a> <a href="#v:enumerateFrom" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromTo">enumerateFromTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromTo" class="link">Source</a> <a href="#v:enumerateFromTo" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThen">enumerateFromThen</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThen" class="link">Source</a> <a href="#v:enumerateFromThen" class="selflink">#</a></p><p class="src"><a href="#v:enumerateFromThenTo">enumerateFromThenTo</a> :: <span class="keyword">forall</span> t (m :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a>). (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Fixed.html#t:Fixed" title="Data.Fixed">Fixed</a> a) <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateFromThenTo" class="link">Source</a> <a href="#v:enumerateFromThenTo" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><a id="v:enumerate" class="def">enumerate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> a) =&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerate" class="link">Source</a> <a href="#v:enumerate" class="selflink">#</a></p><div class="doc"><pre>enumerate = enumerateFrom minBound</pre><p>Enumerate a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> type from its <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:minBound" title="Prelude">minBound</a></code> to <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:maxBound" title="Prelude">maxBound</a></code></p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:enumerateTo" class="def">enumerateTo</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Enumerable" title="Streamly.Internal.Data.Stream.IsStream">Enumerable</a> a) =&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Enumeration.html#enumerateTo" class="link">Source</a> <a href="#v:enumerateTo" class="selflink">#</a></p><div class="doc"><pre>enumerateTo = enumerateFromTo minBound</pre><p>Enumerate a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Bounded" title="Prelude">Bounded</a></code> type from its <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:minBound" title="Prelude">minBound</a></code> to specified value.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:12" id="g:12"><h2>Time Enumeration</h2></a><div class="top"><p class="src"><a id="v:times" class="def">times</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#times" class="link">Source</a> <a href="#v:times" class="selflink">#</a></p><div class="doc"><p><code>times</code> returns a stream of time value tuples with clock of 10 ms
 granularity. The first component of the tuple is an absolute time reference
 (epoch) denoting the start of the stream and the second component is a time
 relative to the reference.</p><pre>&gt;&gt;&gt; S.mapM_ (x -&gt; print x &gt;&gt; threadDelay 1000000) $ S.times
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 0))
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 1002028000))
&gt; (AbsTime (TimeSpec {sec = 2496295, nsec = 536223000}),RelTime64 (NanoSecond64 1996656000))
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:absTimes" class="def">absTimes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#absTimes" class="link">Source</a> <a href="#v:absTimes" class="selflink">#</a></p><div class="doc"><p><code>absTimes</code> returns a stream of absolute timestamps using a clock of 10 ms
 granularity.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.delayPre 1 $ S.absTimes
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:relTimes" class="def">relTimes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#relTimes" class="link">Source</a> <a href="#v:relTimes" class="selflink">#</a></p><div class="doc"><p><code>relTimes</code> returns a stream of relative time values starting from 0,
 using a clock of granularity 10 ms.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.delayPre 1 $ S.relTimes
</pre><p>Note: This API is not safe on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:durations" class="def">durations</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#durations" class="link">Source</a> <a href="#v:durations" class="selflink">#</a></p><div class="doc"><p><code>durations g</code> returns a stream of relative time values measuring the time
 elapsed since the immediate predecessor element of the stream was generated.
 The first element of the stream is always 0. <code>durations</code> uses a clock of
 granularity <code>g</code> specified in seconds. A low granularity clock is more
 expensive in terms of CPU usage. The minimum granularity is 1 millisecond.
 Durations lower than 1 ms will be 0.</p><p>Note: This API is not safe on 32-bit machines.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:ticks" class="def">ticks</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a> -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#ticks" class="link">Source</a> <a href="#v:ticks" class="selflink">#</a></p><div class="doc"><p>Generate ticks at the specified rate. The rate is adaptive, the tick
 generation speed can be increased or decreased at different times to achieve
 the specified rate.  The specific behavior for different styles of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a></code>
 specifications is documented under <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a></code>.  The effective maximum rate
 achieved by a stream is governed by the processor speed.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:timeout" class="def">timeout</a> :: <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> -&gt; t m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#timeout" class="link">Source</a> <a href="#v:timeout" class="selflink">#</a></p><div class="doc"><p>Generate a singleton event at or after the specified absolute time. Note
 that this is different from a threadDelay, a threadDelay starts from the
 time when the action is evaluated, whereas if we use AbsTime based timeout
 it will immediately expire if the action is evaluated too late.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:currentTime" class="def">currentTime</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#currentTime" class="link">Source</a> <a href="#v:currentTime" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use absTimes instead</p></div></div></div><a href="#g:13" id="g:13"><h2>From Generators</h2></a><div class="top"><p class="src"><a id="v:unfoldr" class="def">unfoldr</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; (b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b)) -&gt; b -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#unfoldr" class="link">Source</a> <a href="#v:unfoldr" class="selflink">#</a></p><div class="doc"><pre>unfoldr step s =
    case step s of
        Nothing -&gt; <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:nil" title="Streamly.Internal.Data.Stream.IsStream">nil</a></code>
        Just (a, b) -&gt; a `cons` unfoldr step b
</pre><p>Build a stream by unfolding a <em>pure</em> step function <code>step</code> starting from a
 seed <code>s</code>.  The step function returns the next element in the stream and the
 next seed value. When it is done it returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> and the stream ends.
 For example,</p><pre>let f b =
        if b &gt; 3
        then Nothing
        else Just (b, b + 1)
in toList $ unfoldr f 0
</pre><pre>[0,1,2,3]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfoldrM" class="def">unfoldrM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (b -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, b))) -&gt; b -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#unfoldrM" class="link">Source</a> <a href="#v:unfoldrM" class="selflink">#</a></p><div class="doc"><p>Build a stream by unfolding a <em>monadic</em> step function starting from a
 seed.  The step function returns the next element in the stream and the next
 seed value. When it is done it returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> and the stream ends. For
 example,</p><pre>let f b =
        if b &gt; 3
        then return Nothing
        else print b &gt;&gt; return (Just (b, b + 1))
in drain $ unfoldrM f 0
</pre><pre> 0
 1
 2
 3
</pre><p>When run concurrently, the next unfold step can run concurrently with the
 processing of the output of the previous step.  Note that more than one step
 cannot run concurrently as the next step depends on the output of the
 previous step.</p><pre>(asyncly $ S.unfoldrM (\n -&gt; liftIO (threadDelay 1000000) &gt;&gt; return (Just (n, n + 1))) 0)
    &amp; S.foldlM' (\_ a -&gt; threadDelay 1000000 &gt;&gt; print a) ()
</pre><p><em>Concurrent</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfold" class="def">unfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#unfold" class="link">Source</a> <a href="#v:unfold" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> into a stream by supplying it an input seed.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>unfold (UF.replicateM 10) (putStrLn &quot;hello&quot;)
</code></strong></pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:unfold0" class="def">unfold0</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Void.html#t:Void" title="Data.Void">Void</a> b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#unfold0" class="link">Source</a> <a href="#v:unfold0" class="selflink">#</a></p><div class="doc"><p>Convert an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> with a closed input end into a stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromIndices" class="def">fromIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromIndices" class="link">Source</a> <a href="#v:fromIndices" class="selflink">#</a></p><div class="doc"><pre>fromIndices f = let g i = f i `cons` g (i + 1) in g 0
</pre><p>Generate an infinite stream, whose values are the output of a function <code>f</code>
 applied on the corresponding index.  Index starts at 0.</p><pre>&gt; S.toList $ S.take 5 $ S.fromIndices id
[0,1,2,3,4]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromIndicesM" class="def">fromIndicesM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromIndicesM" class="link">Source</a> <a href="#v:fromIndicesM" class="selflink">#</a></p><div class="doc"><pre>fromIndicesM f = let g i = f i `consM` g (i + 1) in g 0
</pre><p>Generate an infinite stream, whose values are the output of a monadic
 function <code>f</code> applied on the corresponding index. Index starts at 0.</p><p><em>Concurrent</em></p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:14" id="g:14"><h2>Iteration</h2></a><div class="top"><p class="src"><a id="v:iterate" class="def">iterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a) -&gt; a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#iterate" class="link">Source</a> <a href="#v:iterate" class="selflink">#</a></p><div class="doc"><pre>iterate f x = x `cons` iterate f x
</pre><p>Generate an infinite stream with <code>x</code> as the first element and each
 successive element derived by applying the function <code>f</code> on the previous
 element.</p><pre>&gt; S.toList $ S.take 5 $ S.iterate (+1) 1
[1,2,3,4,5]
</pre><p><em>Since: 0.1.2</em></p></div></div><div class="top"><p class="src"><a id="v:iterateM" class="def">iterateM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m a) -&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#iterateM" class="link">Source</a> <a href="#v:iterateM" class="selflink">#</a></p><div class="doc"><pre>iterateM f m = m &gt;&gt;= a -&gt; return a `consM` iterateM f (f a)
</pre><p>Generate an infinite stream with the first element generated by the action
 <code>m</code> and each successive element derived by applying the monadic function
 <code>f</code> on the previous element.</p><p>When run concurrently, the next iteration can run concurrently with the
 processing of the previous iteration. Note that more than one iteration
 cannot run concurrently as the next iteration depends on the output of the
 previous iteration.</p><pre>drain $ serially $ S.take 10 $ S.iterateM
     (\x -&gt; threadDelay 1000000 &gt;&gt; print x &gt;&gt; return (x + 1)) (return 0)

drain $ asyncly  $ S.take 10 $ S.iterateM
     (\x -&gt; threadDelay 1000000 &gt;&gt; print x &gt;&gt; return (x + 1)) (return 0)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.1.2</em></p><p><em>Since: 0.7.0 (signature change)</em></p></div></div><a href="#g:15" id="g:15"><h2>Cyclic Elements</h2></a><div class="top"><p class="src"><a id="v:mfix" class="def">mfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (m a -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamK.html#mfix" class="link">Source</a> <a href="#v:mfix" class="selflink">#</a></p><div class="doc"><p>We can define cyclic structures using <code>let</code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>let (a, b) = ([1, b], head a) in (a, b)
</code></strong>([1,1],1)
</pre><p>The function <code>fix</code> defined as:</p><pre>fix f = let x = f x in x</pre><p>ensures that the argument of a function and its output refer to the same
 lazy value <code>x</code> i.e.  the same location in memory.  Thus <code>x</code> can be defined
 in terms of itself, creating structures with cyclic references.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>f ~(a, b) = ([1, b], head a)
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>fix f
</code></strong>([1,1],1)
</pre><p><code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#v:mfix" title="Control.Monad">mfix</a></code> is essentially the same as <code>fix</code> but for monadic
 values.</p><p>Using <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mfix" title="Streamly.Internal.Data.Stream.IsStream">mfix</a></code> for streams we can construct a stream in which each element of
 the stream is defined in a cyclic fashion. The argument of the function
 being fixed represents the current element of the stream which is being
 returned by the stream monad. Thus, we can use the argument to construct
 itself.</p><p>In the following example, the argument <code>action</code> of the function <code>f</code>
 represents the tuple <code>(x,y)</code> returned by it in a given iteration. We define
 the first element of the tuple in terms of the second.</p><pre>import Streamly.Internal.Data.Stream.IsStream as Stream
import System.IO.Unsafe (unsafeInterleaveIO)

main = do
    Stream.mapM_ print $ Stream.mfix f

    where

    f action = do
        let incr n act = fmap ((+n) . snd) $ unsafeInterleaveIO act
        x &lt;- Stream.fromListM [incr 1 action, incr 2 action]
        y &lt;- Stream.fromList [4,5]
        return (x, y)
</pre><p>Note: you cannot achieve this by just changing the order of the monad
 statements because that would change the order in which the stream elements
 are generated.</p><p>Note that the function <code>f</code> must be lazy in its argument, that's why we use
 <code>unsafeInterleaveIO</code> on <code>action</code> because IO monad is strict.</p><p><em>Internal</em></p></div></div><a href="#g:16" id="g:16"><h2>From Containers</h2></a><div class="top"><p class="src"><a id="v:fromList" class="def">fromList</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; [a] -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Prelude.html#fromList" class="link">Source</a> <a href="#v:fromList" class="selflink">#</a></p><div class="doc"><pre>fromList = <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:cons" title="Streamly.Internal.Data.Stream.IsStream">cons</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:nil" title="Streamly.Internal.Data.Stream.IsStream">nil</a></code>
</pre><p>Construct a stream from a list of pure values. This is more efficient than
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:fromFoldable" title="Streamly.Internal.Data.Stream.IsStream">fromFoldable</a></code> for serial streams.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromListM" class="def">fromListM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; [m a] -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromListM" class="link">Source</a> <a href="#v:fromListM" class="selflink">#</a></p><div class="doc"><pre>fromListM = <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:consM" title="Streamly.Internal.Data.Stream.IsStream">consM</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:nil" title="Streamly.Internal.Data.Stream.IsStream">nil</a></code>
</pre><p>Construct a stream from a list of monadic actions. This is more efficient
 than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:fromFoldableM" title="Streamly.Internal.Data.Stream.IsStream">fromFoldableM</a></code> for serial streams.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromFoldable" class="def">fromFoldable</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamK.html#fromFoldable" class="link">Source</a> <a href="#v:fromFoldable" class="selflink">#</a></p><div class="doc"><pre>fromFoldable = <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:cons" title="Streamly.Internal.Data.Stream.IsStream">cons</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:nil" title="Streamly.Internal.Data.Stream.IsStream">nil</a></code>
</pre><p>Construct a stream from a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> containing pure values:</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromFoldableM" class="def">fromFoldableM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f (m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromFoldableM" class="link">Source</a> <a href="#v:fromFoldableM" class="selflink">#</a></p><div class="doc"><pre>fromFoldableM = <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:foldr" title="Data.Foldable">foldr</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:consM" title="Streamly.Internal.Data.Stream.IsStream">consM</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:nil" title="Streamly.Internal.Data.Stream.IsStream">nil</a></code>
</pre><p>Construct a stream from a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> containing monadic actions.</p><pre>drain $ serially $ S.fromFoldableM $ replicateM 10 (threadDelay 1000000 &gt;&gt; print 1)
drain $ asyncly  $ S.fromFoldableM $ replicateM 10 (threadDelay 1000000 &gt;&gt; print 1)
</pre><p><em>Concurrent (do not use with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> on infinite containers)</em></p><p><em>Since: 0.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromPrimIORef" class="def">fromPrimIORef</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-IORef-Prim.html#t:Prim" title="Streamly.Internal.Data.IORef.Prim">Prim</a> a) =&gt; <a href="Streamly-Internal-Data-IORef-Prim.html#t:IORef" title="Streamly.Internal.Data.IORef.Prim">IORef</a> a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromPrimIORef" class="link">Source</a> <a href="#v:fromPrimIORef" class="selflink">#</a></p><div class="doc"><p>Construct a stream by reading a <code><a href="Streamly-Internal-Data-IORef-Prim.html#t:Prim" title="Streamly.Internal.Data.IORef.Prim">Prim</a></code> <code><a href="Streamly-Internal-Data-IORef-Prim.html#t:IORef" title="Streamly.Internal.Data.IORef.Prim">IORef</a></code> repeatedly.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:fromCallback" class="def">fromCallback</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m =&gt; ((a -&gt; m ()) -&gt; m ()) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromCallback" class="link">Source</a> <a href="#v:fromCallback" class="selflink">#</a></p><div class="doc"><p>Takes a callback setter function and provides it with a callback.  The
 callback when invoked adds a value at the tail of the stream. Returns a
 stream of values generated by the callback.</p><p><em>Internal</em></p></div></div><a href="#g:17" id="g:17"><h1>Elimination</h1></a><a href="#g:18" id="g:18"><h2>Deconstruction</h2></a><div class="top"><p class="src"><a id="v:uncons" class="def">uncons</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, t m a)) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#uncons" class="link">Source</a> <a href="#v:uncons" class="selflink">#</a></p><div class="doc"><p>Decompose a stream into its head and tail. If the stream is empty, returns
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>. If the stream is non-empty, returns <code>Just (a, ma)</code>, where <code>a</code> is
 the head of the stream and <code>ma</code> its tail.</p><p>This is a brute force primitive. Avoid using it as long as possible, use it
 when no other combinator can do the job. This can be used to do pretty much
 anything in an imperative manner, as it just breaks down the stream into
 individual elements and we can loop over them as we deem fit. For example,
 this can be used to convert a streamly stream into other stream types.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:tail" class="def">tail</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#tail" class="link">Source</a> <a href="#v:tail" class="selflink">#</a></p><div class="doc"><pre>tail = fmap (fmap snd) . uncons</pre><p>Extract all but the first element of the stream, if any.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:init" class="def">init</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#init" class="link">Source</a> <a href="#v:init" class="selflink">#</a></p><div class="doc"><p>Extract all but the last element of the stream, if any.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:19" id="g:19"><h2>Folding</h2></a><a href="#g:20" id="g:20"><h2>Right Folds</h2></a><div class="top"><p class="src"><a id="v:foldrM" class="def">foldrM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldrM" class="link">Source</a> <a href="#v:foldrM" class="selflink">#</a></p><div class="doc"><p>Right associative/lazy pull fold. <code>foldrM build final stream</code> constructs
 an output structure using the step function <code>build</code>. <code>build</code> is invoked with
 the next input element and the remaining (lazy) tail of the output
 structure. It builds a lazy output expression using the two. When the &quot;tail
 structure&quot; in the output expression is evaluated it calls <code>build</code> again thus
 lazily consuming the input <code>stream</code> until either the output expression built
 by <code>build</code> is free of the &quot;tail&quot; or the input is exhausted in which case
 <code>final</code> is used as the terminating case for the output structure. For more
 details see the description in the previous section.</p><p>Example, determine if any element is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:odd" title="Prelude">odd</a></code> in a stream:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.foldrM (\x xs -&gt; if odd x then return True else xs) (return False) $ S.fromList (2:4:5:undefined)
</code></strong>&gt; True
</pre><p><em>Since: 0.7.0 (signature changed)</em></p><p><em>Since: 0.2.0 (signature changed)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldrS" class="def">foldrS</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (a -&gt; t m b -&gt; t m b) -&gt; t m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldrS" class="link">Source</a> <a href="#v:foldrS" class="selflink">#</a></p><div class="doc"><p>Right fold to a streaming monad.</p><pre>foldrS S.cons S.nil === id</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream">foldrS</a></code> can be used to perform stateless stream to stream transformations
 like map and filter in general. It can be coupled with a scan to perform
 stateful transformations. However, note that the custom map and filter
 routines can be much more efficient than this due to better stream fusion.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS S.cons S.nil $ S.fromList [1..5]
</code></strong>&gt; [1,2,3,4,5]
</pre><p>Find if any element in the stream is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS (\x xs -&gt; if odd x then return True else xs) (return False) $ (S.fromList (2:4:5:undefined) :: SerialT IO Int)
</code></strong>&gt; [True]
</pre><p>Map (+2) on odd elements and filter out the even elements:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.foldrS (\x xs -&gt; if odd x then (x + 2) `S.cons` xs else xs) S.nil $ (S.fromList [1..5] :: SerialT IO Int)
</code></strong>&gt; [3,5,7]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrM" title="Streamly.Internal.Data.Stream.IsStream">foldrM</a></code> can also be represented in terms of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream">foldrS</a></code>, however, the former
 is much more efficient:</p><pre>foldrM f z s = runIdentityT $ foldrS (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:foldrT" class="def">foldrT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (s m), <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> s) =&gt; (a -&gt; s m b -&gt; s m b) -&gt; s m b -&gt; t m a -&gt; s m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldrT" class="link">Source</a> <a href="#v:foldrT" class="selflink">#</a></p><div class="doc"><p>Right fold to a transformer monad.  This is the most general right fold
 function. <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream">foldrS</a></code> is a special case of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrT" title="Streamly.Internal.Data.Stream.IsStream">foldrT</a></code>, however <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrS" title="Streamly.Internal.Data.Stream.IsStream">foldrS</a></code>
 implementation can be more efficient:</p><pre>foldrS = foldrT
foldrM f z s = runIdentityT $ foldrT (\x xs -&gt; lift $ f x (runIdentityT xs)) (lift z) s</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldrT" title="Streamly.Internal.Data.Stream.IsStream">foldrT</a></code> can be used to translate streamly streams to other transformer
 monads e.g.  to a different streaming type.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:foldr" class="def">foldr</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; b -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldr" class="link">Source</a> <a href="#v:foldr" class="selflink">#</a></p><div class="doc"><p>Right fold, lazy for lazy monads and pure streams, and strict for strict
 monads.</p><p>Please avoid using this routine in strict monads like IO unless you need a
 strict right fold. This is provided only for use in lazy monads (e.g.
 Identity) or pure streams. Note that with this signature it is not possible
 to implement a lazy foldr when the monad <code>m</code> is strict. In that case it
 would be strict in its accumulator and therefore would necessarily consume
 all its input.</p><p><em>Since: 0.1.0</em></p></div></div><a href="#g:21" id="g:21"><h2>Left Folds</h2></a><div class="top"><p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldl%27" class="link">Source</a> <a href="#v:foldl-39-" class="selflink">#</a></p><div class="doc"><p>Left associative/strict push fold. <code>foldl' reduce initial stream</code> invokes
 <code>reduce</code> with the accumulator and the next input in the input stream, using
 <code>initial</code> as the initial value of the current value of the accumulator. When
 the input is exhausted the current value of the accumulator is returned.
 Make sure to use a strict data structure for accumulator to not build
 unnecessary lazy expressions unless that's what you want. See the previous
 section for more details.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldl1%27" class="link">Source</a> <a href="#v:foldl1-39-" class="selflink">#</a></p><div class="doc"><p>Strict left fold, for non-empty streams, using first element as the
 starting value. Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the stream is empty.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldlM-39-" class="def">foldlM'</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldlM%27" class="link">Source</a> <a href="#v:foldlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldl-39-" title="Streamly.Internal.Data.Stream.IsStream">foldl'</a></code> but with a monadic step function.</p><p><em>Since: 0.2.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><a href="#g:22" id="g:22"><h2>Composable Left Folds</h2></a><div class="top"><p class="src"><a id="v:fold" class="def">fold</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fold" class="link">Source</a> <a href="#v:fold" class="selflink">#</a></p><div class="doc"><p>Fold a stream using the supplied left fold.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.fold FL.sum (S.enumerateFromTo 1 100)
</code></strong>5050
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:parse" class="def">parse</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parse" class="link">Source</a> <a href="#v:parse" class="selflink">#</a></p><div class="doc"><p>Parse a stream using the supplied <code><a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:parseK" class="def">parseK</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseK" class="link">Source</a> <a href="#v:parseK" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:parseD" class="def">parseD</a> :: <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseD" class="link">Source</a> <a href="#v:parseD" class="selflink">#</a></p><div class="doc"><p>Parse a stream using the supplied <code><a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a></code>.</p><p><em>Internal</em></p></div></div><a href="#g:23" id="g:23"><h2>Concurrent Folds</h2></a><div class="top"><p class="src"><a id="v:foldAsync" class="def">foldAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldAsync" class="link">Source</a> <a href="#v:foldAsync" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:-124--36-." title="Streamly.Internal.Data.Stream.IsStream">|$.</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:-124--36-." class="def">(|$.)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; m b) -&gt; t m a -&gt; m b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#%7C%24." class="link">Source</a> <a href="#v:-124--36-." class="selflink">#</a></p><div class="doc"><p>Parallel fold application operator; applies a fold function <code>t m a -&gt; m b</code>
 to a stream <code>t m a</code> concurrently; The the input stream is evaluated
 asynchronously in an independent thread yielding elements to a buffer and
 the folding action runs in another thread consuming the input from the
 buffer.</p><p>If you read the signature as <code>(t m a -&gt; m b) -&gt; (t m a -&gt; m b)</code> you can look
 at it as a transformation that converts a fold function to a buffered
 concurrent fold function.</p><p>The <code>.</code> at the end of the operator is a mnemonic for termination of the
 stream.</p><pre>   S.foldlM' (\_ a -&gt; threadDelay 1000000 &gt;&gt; print a) ()
      |$. S.repeatM (threadDelay 1000000 &gt;&gt; return 1)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:-124--38-." class="def">(|&amp;.)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; m b) -&gt; m b <span class="fixity">infixl 1</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#%7C%26." class="link">Source</a> <a href="#v:-124--38-." class="selflink">#</a></p><div class="doc"><p>Parallel reverse function application operator for applying a run or fold
 functions to a stream. Just like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:-124--36-." title="Streamly.Internal.Data.Stream.IsStream">|$.</a></code> except that the operands are reversed.</p><pre>       S.repeatM (threadDelay 1000000 &gt;&gt; return 1)
   |&amp;. S.foldlM' (\_ a -&gt; threadDelay 1000000 &gt;&gt; print a) ()
</pre><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:24" id="g:24"><h2>Full Folds</h2></a><div class="top"><p class="src"><a id="v:drain" class="def">drain</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#drain" class="link">Source</a> <a href="#v:drain" class="selflink">#</a></p><div class="doc"><pre>drain = mapM_ (\_ -&gt; return ())</pre><p>Run a stream, discarding the results. By default it interprets the stream
 as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>, to run other types of streams use the type adapting
 combinators for example <code>drain . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:asyncly" title="Streamly.Internal.Data.Stream.IsStream">asyncly</a></code></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:last" class="def">last</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#last" class="link">Source</a> <a href="#v:last" class="selflink">#</a></p><div class="doc"><p>Extract the last element of the stream, if any.</p><pre>last xs = xs !! (length xs - 1)</pre><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:length" class="def">length</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#length" class="link">Source</a> <a href="#v:length" class="selflink">#</a></p><div class="doc"><p>Determine the length of the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:sum" class="def">sum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#sum" class="link">Source</a> <a href="#v:sum" class="selflink">#</a></p><div class="doc"><p>Determine the sum of all elements of a stream of numbers. Returns <code>0</code> when
 the stream is empty. Note that this is not numerically stable for floating
 point numbers.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:product" class="def">product</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Num" title="Prelude">Num</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#product" class="link">Source</a> <a href="#v:product" class="selflink">#</a></p><div class="doc"><p>Determine the product of all elements of a stream of numbers. Returns <code>1</code>
 when the stream is empty.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:mconcat" class="def">mconcat</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mconcat" class="link">Source</a> <a href="#v:mconcat" class="selflink">#</a></p><div class="doc"><p>Fold a stream of monoid elements by appending them.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:maximumBy" class="def">maximumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#maximumBy" class="link">Source</a> <a href="#v:maximumBy" class="selflink">#</a></p><div class="doc"><p>Determine the maximum element in a stream using the supplied comparison
 function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#maximum" class="link">Source</a> <a href="#v:maximum" class="selflink">#</a></p><div class="doc"><pre>maximum = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maximumBy" title="Streamly.Internal.Data.Stream.IsStream">maximumBy</a></code> compare
</pre><p>Determine the maximum element in a stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimumBy" class="def">minimumBy</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#minimumBy" class="link">Source</a> <a href="#v:minimumBy" class="selflink">#</a></p><div class="doc"><p>Determine the minimum element in a stream using the supplied comparison
 function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#minimum" class="link">Source</a> <a href="#v:minimum" class="selflink">#</a></p><div class="doc"><pre>minimum = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:minimumBy" title="Streamly.Internal.Data.Stream.IsStream">minimumBy</a></code> compare
</pre><p>Determine the minimum element in a stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:the" class="def">the</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#the" class="link">Source</a> <a href="#v:the" class="selflink">#</a></p><div class="doc"><p>Ensures that all the elements of the stream are identical and then returns
 that unique element.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:25" id="g:25"><h2>Lazy Folds</h2></a><div class="top"><p class="src"><a id="v:toList" class="def">toList</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m [a] <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toList" class="link">Source</a> <a href="#v:toList" class="selflink">#</a></p><div class="doc"><pre>toList = S.foldr (:) []
</pre><p>Convert a stream into a list in the underlying monad. The list can be
 consumed lazily in a lazy monad (e.g. <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code>). In a strict monad (e.g.
 IO) the whole list is generated and buffered before it can be consumed.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:toListRev" class="def">toListRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m [a] <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toListRev" class="link">Source</a> <a href="#v:toListRev" class="selflink">#</a></p><div class="doc"><pre>toListRev = S.foldl' (flip (:)) []
</pre><p>Convert a stream into a list in reverse order in the underlying monad.</p><p><em>Warning!</em> working on large lists accumulated as buffers in memory could be
 very inefficient, consider using <a href="Streamly-Array.html">Streamly.Array</a> instead.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toPure" class="def">toPure</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toPure" class="link">Source</a> <a href="#v:toPure" class="selflink">#</a></p><div class="doc"><p>Convert a stream to a pure stream.</p><pre>toPure = foldr cons nil
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toPureRev" class="def">toPureRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toPureRev" class="link">Source</a> <a href="#v:toPureRev" class="selflink">#</a></p><div class="doc"><p>Convert a stream to a pure stream in reverse order.</p><pre>toPureRev = foldl' (flip cons) nil
</pre><p><em>Internal</em></p></div></div><a href="#g:26" id="g:26"><h2>Composable Left Folds</h2></a><div class="top"><p class="src"><a id="v:toStream" class="def">toStream</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toStream" class="link">Source</a> <a href="#v:toStream" class="selflink">#</a></p><div class="doc"><p>A fold that buffers its input to a pure stream.</p><p><em>Warning!</em> working on large streams accumulated as buffers in memory could
 be very inefficient, consider using <a href="Streamly-Data-Array.html">Streamly.Data.Array</a> instead.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:toStreamRev" class="def">toStreamRev</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toStreamRev" class="link">Source</a> <a href="#v:toStreamRev" class="selflink">#</a></p><div class="doc"><p>Buffers the input stream to a pure stream in the reverse order of the
 input.</p><p><em>Warning!</em> working on large streams accumulated as buffers in memory could
 be very inefficient, consider using <a href="Streamly-Data-Array.html">Streamly.Data.Array</a> instead.</p><p><em>Internal</em></p></div></div><a href="#g:27" id="g:27"><h2>Partial Folds</h2></a><div class="top"><p class="src"><a id="v:drainN" class="def">drainN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#drainN" class="link">Source</a> <a href="#v:drainN" class="selflink">#</a></p><div class="doc"><pre>drainN n = drain . take n</pre><p>Run maximum up to <code>n</code> iterations of a stream.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:drainWhile" class="def">drainWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#drainWhile" class="link">Source</a> <a href="#v:drainWhile" class="selflink">#</a></p><div class="doc"><pre>drainWhile p = drain . takeWhile p</pre><p>Run a stream as long as the predicate holds true.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#%21%21" class="link">Source</a> <a href="#v:-33--33-" class="selflink">#</a></p><div class="doc"><p>Lookup the element at the given index.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:head" class="def">head</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#head" class="link">Source</a> <a href="#v:head" class="selflink">#</a></p><div class="doc"><p>Extract the first element of the stream, if any.</p><pre>head = (!! 0)</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:headElse" class="def">headElse</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#headElse" class="link">Source</a> <a href="#v:headElse" class="selflink">#</a></p><div class="doc"><p>Extract the first element of the stream, if any, otherwise use the
 supplied default value. It can help avoid one branch in high performance
 code.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:findM" class="def">findM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#findM" class="link">Source</a> <a href="#v:findM" class="selflink">#</a></p><div class="doc"><p>Returns the first element that satisfies the given predicate.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:find" class="def">find</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#find" class="link">Source</a> <a href="#v:find" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:findM" title="Streamly.Internal.Data.Stream.IsStream">findM</a></code> but with a non-monadic predicate.</p><pre>find p = findM (return . p)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:lookup" class="def">lookup</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m (a, b) -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#lookup" class="link">Source</a> <a href="#v:lookup" class="selflink">#</a></p><div class="doc"><p>In a stream of (key-value) pairs <code>(a, b)</code>, return the value <code>b</code> of the
 first pair where the key equals the given value <code>a</code>.</p><pre>lookup = snd &lt;$&gt; find ((==) . fst)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:findIndex" class="def">findIndex</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#findIndex" class="link">Source</a> <a href="#v:findIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index that satisfies the given predicate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndex" class="def">elemIndex</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#elemIndex" class="link">Source</a> <a href="#v:elemIndex" class="selflink">#</a></p><div class="doc"><p>Returns the first index where a given value is found in the stream.</p><pre>elemIndex a = findIndex (== a)</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:null" class="def">null</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#null" class="link">Source</a> <a href="#v:null" class="selflink">#</a></p><div class="doc"><p>Determine whether the stream is empty.</p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:elem" class="def">elem</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#elem" class="link">Source</a> <a href="#v:elem" class="selflink">#</a></p><div class="doc"><p>Determine whether an element is present in the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:notElem" class="def">notElem</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#notElem" class="link">Source</a> <a href="#v:notElem" class="selflink">#</a></p><div class="doc"><p>Determine whether an element is not present in the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:all" class="def">all</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#all" class="link">Source</a> <a href="#v:all" class="selflink">#</a></p><div class="doc"><p>Determine whether all elements of a stream satisfy a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:any" class="def">any</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#any" class="link">Source</a> <a href="#v:any" class="selflink">#</a></p><div class="doc"><p>Determine whether any of the elements of a stream satisfy a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:and" class="def">and</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#and" class="link">Source</a> <a href="#v:and" class="selflink">#</a></p><div class="doc"><p>Determines if all elements of a boolean stream are True.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:or" class="def">or</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#or" class="link">Source</a> <a href="#v:or" class="selflink">#</a></p><div class="doc"><p>Determines whether at least one element of a boolean stream is True.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:28" id="g:28"><h2>Multi-Stream folds</h2></a><div class="top"><p class="src"><a id="v:eqBy" class="def">eqBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#eqBy" class="link">Source</a> <a href="#v:eqBy" class="selflink">#</a></p><div class="doc"><p>Compare two streams for equality using an equality function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:cmpBy" class="def">cmpBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m b -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#cmpBy" class="link">Source</a> <a href="#v:cmpBy" class="selflink">#</a></p><div class="doc"><p>Compare two streams lexicographically using a comparison function.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:isPrefixOf" class="def">isPrefixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#isPrefixOf" class="link">Source</a> <a href="#v:isPrefixOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the first stream is the same as or a prefix of the
 second. A stream is a prefix of itself.</p><pre>&gt; S.isPrefixOf (S.fromList &quot;hello&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:isSuffixOf" class="def">isSuffixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#isSuffixOf" class="link">Source</a> <a href="#v:isSuffixOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the first stream is a suffix of the second. A stream is
 considered a suffix of itself.</p><pre>&gt; S.isSuffixOf (S.fromList &quot;hello&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p>Space: <code>O(n)</code>, buffers entire input stream and the suffix.</p><p><em>Internal</em></p><p><em>Suboptimal</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:isInfixOf" class="def">isInfixOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#isInfixOf" class="link">Source</a> <a href="#v:isInfixOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if the first stream is an infix of the second. A stream is
 considered an infix of itself.</p><pre>&gt; S.isInfixOf (S.fromList &quot;hello&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p>Space: <code>O(n)</code> worst case where <code>n</code> is the length of the infix.</p><p><em>Internal</em></p><p><em>Requires <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> constraint</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:isSubsequenceOf" class="def">isSubsequenceOf</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#isSubsequenceOf" class="link">Source</a> <a href="#v:isSubsequenceOf" class="selflink">#</a></p><div class="doc"><p>Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> if all the elements of the first stream occur, in order, in
 the second stream. The elements do not have to occur consecutively. A stream
 is a subsequence of itself.</p><pre>&gt; S.isSubsequenceOf (S.fromList &quot;hlo&quot;) (S.fromList &quot;hello&quot; :: SerialT IO Char)
True
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:stripPrefix" class="def">stripPrefix</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (t m a)) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#stripPrefix" class="link">Source</a> <a href="#v:stripPrefix" class="selflink">#</a></p><div class="doc"><p>Strip prefix if present and tell whether it was stripped or not. Returns
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the stream does not start with the given prefix, stripped
 stream otherwise. Returns <code>Just nil</code> when the prefix is the same as the
 stream.</p><p>Space: <code>O(1)</code></p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:stripSuffix" class="def">stripSuffix</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a)) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#stripSuffix" class="link">Source</a> <a href="#v:stripSuffix" class="selflink">#</a></p><div class="doc"><p>Drops the given suffix from a stream. Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the stream does
 not end with the given suffix. Returns <code>Just nil</code> when the suffix is the
 same as the stream.</p><p>It may be more efficient to convert the stream to an Array and use
 stripSuffix on that especially if the elements have a Storable or Prim
 instance.</p><p>Space: <code>O(n)</code>, buffers the entire input stream as well as the suffix</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dropPrefix" class="def">dropPrefix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropPrefix" class="link">Source</a> <a href="#v:dropPrefix" class="selflink">#</a></p><div class="doc"><p>Drop prefix from the input stream if present.</p><p>Space: <code>O(1)</code></p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropInfix" class="def">dropInfix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropInfix" class="link">Source</a> <a href="#v:dropInfix" class="selflink">#</a></p><div class="doc"><p>Drop all matching infix from the input stream if present. Infix stream
 may be consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the infix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><div class="top"><p class="src"><a id="v:dropSuffix" class="def">dropSuffix</a> :: t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropSuffix" class="link">Source</a> <a href="#v:dropSuffix" class="selflink">#</a></p><div class="doc"><p>Drop suffix from the input stream if present. Suffix stream may be
 consumed multiple times.</p><p>Space: <code>O(n)</code> where n is the length of the suffix.</p><p><em>Unimplemented</em> - Help wanted.</p></div></div><a href="#g:29" id="g:29"><h1>Transformation</h1></a><div class="top"><p class="src"><a id="v:transform" class="def">transform</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#transform" class="link">Source</a> <a href="#v:transform" class="selflink">#</a></p><div class="doc"><p>Use a <code><a href="Streamly-Internal-Data-Pipe-Types.html#t:Pipe" title="Streamly.Internal.Data.Pipe.Types">Pipe</a></code> to transform a stream.</p><p><em>Internal</em></p></div></div><a href="#g:30" id="g:30"><h2>Mapping</h2></a><div class="top"><p class="src"><a id="v:map" class="def">map</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.Serial.html#map" class="link">Source</a> <a href="#v:map" class="selflink">#</a></p><div class="doc"><pre>map = fmap
</pre><p>Same as <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#v:fmap" title="Data.Functor">fmap</a></code>.</p><pre>&gt; S.toList $ S.map (+1) $ S.fromList [1,2,3]
[2,3,4]
</pre><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:sequence" class="def">sequence</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m (m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#sequence" class="link">Source</a> <a href="#v:sequence" class="selflink">#</a></p><div class="doc"><pre>sequence = mapM id
</pre><p>Replace the elements of a stream of monadic actions with the outputs of
 those actions.</p><pre>&gt; drain $ S.sequence $ S.fromList [putStr &quot;a&quot;, putStr &quot;b&quot;, putStrLn &quot;c&quot;]
abc

drain $ S.replicateM 10 (return $ threadDelay 1000000 &gt;&gt; print 1)
          &amp; (serially . S.sequence)

drain $ S.replicateM 10 (return $ threadDelay 1000000 &gt;&gt; print 1)
          &amp; (asyncly . S.sequence)
</pre><p><em>Concurrent (do not use with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapM" class="def">mapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mapM" class="link">Source</a> <a href="#v:mapM" class="selflink">#</a></p><div class="doc"><pre>mapM f = sequence . map f
</pre><p>Apply a monadic function to each element of the stream and replace it with
 the output of the resulting action.</p><pre>&gt; drain $ S.mapM putStr $ S.fromList [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]
abc

drain $ S.replicateM 10 (return 1)
          &amp; (serially . S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x))

drain $ S.replicateM 10 (return 1)
          &amp; (asyncly . S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x))
</pre><p><em>Concurrent (do not use with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> on infinite streams)</em></p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:smapM" class="def">smapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (s -&gt; a -&gt; m (s, b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#smapM" class="link">Source</a> <a href="#v:smapM" class="selflink">#</a></p><div class="doc"><p>A stateful <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mapM" title="Streamly.Internal.Data.Stream.IsStream">mapM</a></code>, equivalent to a left scan, more like mapAccumL.
 Hopefully, this is a better alternative to <code>scan</code>. Separation of state from
 the output makes it easier to think in terms of a shared state, and also
 makes it easier to keep the state fully strict and the output lazy.</p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanlM-39-" title="Streamly.Internal.Data.Stream.IsStream">scanlM'</a></code></p><p><em>Internal</em></p></div></div><div class="doc"><p>The stateful step function can be simplified to <code>(s -&gt; a -&gt; m b)</code> to provide
 a read-only environment. However, that would just be <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mapM" title="Streamly.Internal.Data.Stream.IsStream">mapM</a></code>.</p><p>The initial action could be <code>m (s, Maybe b)</code>, and we can also add a final
 action <code>s -&gt; m (Maybe b)</code>. This can be used to get pre/post scan like
 functionality and also to flush the state in the end like scanlMAfter'.
 We can also use it along with a fusible version of bracket to get
 scanlMAfter' like functionality. See issue #677.</p><p>This can be further generalized to a type similar to Fold/Parser, giving it
 filtering and parsing capability as well (this is in fact equivalent to
 parseMany):</p><p>smapM :: (s -&gt; a -&gt; m (Step s b)) -&gt; m s -&gt; t m a -&gt; t m b</p></div><a href="#g:31" id="g:31"><h2>Special Maps</h2></a><div class="top"><p class="src"><a id="v:mapM_" class="def">mapM_</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mapM_" class="link">Source</a> <a href="#v:mapM_" class="selflink">#</a></p><div class="doc"><pre>mapM_ = drain . mapM</pre><p>Apply a monadic action to each element of the stream and discard the output
 of the action. This is not really a pure transformation operation but a
 transformation followed by fold.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:trace" class="def">trace</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#trace" class="link">Source</a> <a href="#v:trace" class="selflink">#</a></p><div class="doc"><p>Apply a monadic function to each element flowing through the stream and
 discard the results.</p><pre>&gt; S.drain $ S.trace print (S.enumerateFromTo 1 2)
1
2
</pre><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:tap" title="Streamly.Internal.Data.Stream.IsStream">tap</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:trace_" class="def">trace_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#trace_" class="link">Source</a> <a href="#v:trace_" class="selflink">#</a></p><div class="doc"><p>Perform a side effect before yielding each element of the stream and
 discard the results.</p><pre>&gt; S.drain $ S.trace_ (print &quot;got here&quot;) (S.enumerateFromTo 1 2)
&quot;got here&quot;
&quot;got here&quot;
</pre><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:trace" title="Streamly.Internal.Data.Stream.IsStream">trace</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interspersePrefix_" title="Streamly.Internal.Data.Stream.IsStream">interspersePrefix_</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:tap" class="def">tap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#tap" class="link">Source</a> <a href="#v:tap" class="selflink">#</a></p><div class="doc"><p>Tap the data flowing through a stream into a <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code>. For example, you may
 add a tap to log the contents flowing through the stream. The fold is used
 only for effects, its result is discarded.</p><pre>                  Fold m a b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt; S.drain $ S.tap (FL.drainBy print) (S.enumerateFromTo 1 2)
1
2
</pre><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:trace" title="Streamly.Internal.Data.Stream.IsStream">trace</a></code>.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:tapOffsetEvery" class="def">tapOffsetEvery</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#tapOffsetEvery" class="link">Source</a> <a href="#v:tapOffsetEvery" class="selflink">#</a></p><div class="doc"><p><code>tapOffsetEvery offset n</code> taps every <code>n</code>th element in the stream
 starting at <code>offset</code>. <code>offset</code> can be between <code>0</code> and <code>n - 1</code>. Offset 0
 means start at the first element in the stream. If the offset is outside
 this range then <code>offset <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:mod" title="Prelude">mod</a></code> n</code> is used as offset.</p><pre>&gt;&gt;&gt; S.drain $ S.tapOffsetEvery 0 2 (FL.mapM print FL.toList) $ S.enumerateFromTo 0 10
&gt; [0,2,4,6,8,10]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:tapAsync" class="def">tapAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#tapAsync" class="link">Source</a> <a href="#v:tapAsync" class="selflink">#</a></p><div class="doc"><p>Redirect a copy of the stream to a supplied fold and run it concurrently
 in an independent thread. The fold may buffer some elements. The buffer size
 is determined by the prevailing <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream">maxBuffer</a></code> setting.</p><pre>              Stream m a -&gt; m b
                      |
-----stream m a ---------------stream m a-----

</pre><pre>&gt; S.drain $ S.tapAsync (S.mapM_ print) (S.enumerateFromTo 1 2)
1
2
</pre><p>Exceptions from the concurrently running fold are propagated to the current
 computation.  Note that, because of buffering in the fold, exceptions may be
 delayed and may not correspond to the current element being processed in the
 parent stream, but we guarantee that before the parent stream stops the tap
 finishes and all exceptions from it are drained.</p><p>Compare with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:tap" title="Streamly.Internal.Data.Stream.IsStream">tap</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:tapRate" class="def">tapRate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m b) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#tapRate" class="link">Source</a> <a href="#v:tapRate" class="selflink">#</a></p><div class="doc"><p>Calls the supplied function with the number of elements consumed
 every <code>n</code> seconds. The given function is run in a separate thread
 until the end of the stream. In case there is an exception in the
 stream the thread is killed during the next major GC.</p><p>Note: The action is not guaranteed to run if the main thread exits.</p><pre>&gt; delay n = threadDelay (round $ n * 1000000) &gt;&gt; return n
&gt; S.drain $ S.tapRate 2 (\n -&gt; print $ show n ++ &quot; elements processed&quot;) (delay 1 S.|: delay 0.5 S.|: delay 0.5 S.|: S.nil)
2 elements processed
1 elements processed
</pre><p>Note: This may not work correctly on 32-bit machines.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:pollCounts" class="def">pollCounts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; (t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#pollCounts" class="link">Source</a> <a href="#v:pollCounts" class="selflink">#</a></p><div class="doc"><p><code>pollCounts predicate transform fold stream</code> counts those elements in the
 stream that pass the <code>predicate</code>. The resulting count stream is sent to
 another thread which transforms it using <code>transform</code> and then folds it using
 <code>fold</code>.  The thread is automatically cleaned up if the stream stops or
 aborts due to exception.</p><p>For example, to print the count of elements processed every second:</p><pre>&gt; S.drain $ S.pollCounts (const True) (S.rollingMap (-) . S.delayPost 1) (FL.drainBy print)
          $ S.enumerateFrom 0
</pre><p>Note: This may not work correctly on 32-bit machines.</p><p><em>Internal</em></p></div></div><a href="#g:32" id="g:32"><h2>Scanning</h2></a><a href="#g:33" id="g:33"><h2>Left scans</h2></a><div class="top"><p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanl%27" class="link">Source</a> <a href="#v:scanl-39-" class="selflink">#</a></p><div class="doc"><p>Strict left scan. Like <code>map</code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> too is a one to one transformation,
 however it adds an extra element.</p><pre>&gt; S.toList $ S.scanl' (+) 0 $ fromList [1,2,3,4]
[0,1,3,6,10]
</pre><pre>&gt; S.toList $ S.scanl' (flip (:)) [] $ S.fromList [1,2,3,4]
[[],[1],[2,1],[3,2,1],[4,3,2,1]]
</pre><p>The output of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> is the initial value of the accumulator followed by
 all the intermediate steps and the final result of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldl-39-" title="Streamly.Internal.Data.Stream.IsStream">foldl'</a></code>.</p><p>By streaming the accumulated state after each fold step, we can share the
 state across multiple stages of stream composition. Each stage can modify or
 extend the state, do some processing with it and emit it for the next stage,
 thus modularizing the stream processing. This can be useful in
 stateful or event-driven programming.</p><p>Consider the following monolithic example, computing the sum and the product
 of the elements in a stream in one go using a <code>foldl'</code>:</p><pre>&gt; S.foldl' (\(s, p) x -&gt; (s + x, p * x)) (0,1) $ S.fromList [1,2,3,4]
(10,24)
</pre><p>Using <code>scanl'</code> we can make it modular by computing the sum in the first
 stage and passing it down to the next stage for computing the product:</p><pre>&gt;   S.foldl' (\(_, p) (s, x) -&gt; (s, p * x)) (0,1)
  $ S.scanl' (\(s, _) x -&gt; (s + x, x)) (0,1)
  $ S.fromList [1,2,3,4]
(10,24)
</pre><p>IMPORTANT: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> evaluates the accumulator to WHNF.  To avoid building
 lazy expressions inside the accumulator, it is recommended that a strict
 data structure is used for accumulator.</p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:usingStateT" title="Streamly.Internal.Data.Stream.IsStream">usingStateT</a></code></p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanlM-39-" class="def">scanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanlM%27" class="link">Source</a> <a href="#v:scanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> but with a monadic step function and a monadic seed.</p><p><em>Since: 0.4.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:scanlMAfter-39-" class="def">scanlMAfter'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; (b -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanlMAfter%27" class="link">Source</a> <a href="#v:scanlMAfter-39-" class="selflink">#</a></p><div class="doc"><p><code>scanlMAfter' accumulate initial done stream</code> is like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanlM-39-" title="Streamly.Internal.Data.Stream.IsStream">scanlM'</a></code> except
 that it provides an additional <code>done</code> function to be applied on the
 accumulator when the stream stops. The result of <code>done</code> is also emitted in
 the stream.</p><p>This function can be used to allocate a resource in the beginning of the
 scan and release it when the stream ends or to flush the internal state of
 the scan at the end.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:postscanl-39-" class="def">postscanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#postscanl%27" class="link">Source</a> <a href="#v:postscanl-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> but does not stream the initial value of the accumulator.</p><pre>postscanl' f z xs = S.drop 1 $ S.scanl' f z xs</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscanlM-39-" class="def">postscanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#postscanlM%27" class="link">Source</a> <a href="#v:postscanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:postscanl-39-" title="Streamly.Internal.Data.Stream.IsStream">postscanl'</a></code> but with a monadic step function and a monadic seed.</p><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:prescanl-39-" class="def">prescanl'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#prescanl%27" class="link">Source</a> <a href="#v:prescanl-39-" class="selflink">#</a></p><div class="doc"><p>Like scanl' but does not stream the final value of the accumulator.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:prescanlM-39-" class="def">prescanlM'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (b -&gt; a -&gt; m b) -&gt; m b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#prescanlM%27" class="link">Source</a> <a href="#v:prescanlM-39-" class="selflink">#</a></p><div class="doc"><p>Like prescanl' but with a monadic step function and a monadic seed.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1-39-" class="def">scanl1'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanl1%27" class="link">Source</a> <a href="#v:scanl1-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code> but for a non-empty stream. The first element of the stream
 is used as the initial value of the accumulator. Does nothing if the stream
 is empty.</p><pre>&gt; S.toList $ S.scanl1 (+) $ fromList [1,2,3,4]
[1,3,6,10]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanl1M-39-" class="def">scanl1M'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanl1M%27" class="link">Source</a> <a href="#v:scanl1M-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl1-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl1'</a></code> but with a monadic step function.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:34" id="g:34"><h2>Scan Using Fold</h2></a><div class="top"><p class="src"><a id="v:scan" class="def">scan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scan" class="link">Source</a> <a href="#v:scan" class="selflink">#</a></p><div class="doc"><p>Scan a stream using the given monadic fold.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:postscan" class="def">postscan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#postscan" class="link">Source</a> <a href="#v:postscan" class="selflink">#</a></p><div class="doc"><p>Postscan a stream using the given monadic fold.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:35" id="g:35"><h2>Concurrent Transformation</h2></a><div class="top"><p class="src"><a id="v:mkParallel" class="def">mkParallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamD.html#mkParallel" class="link">Source</a> <a href="#v:mkParallel" class="selflink">#</a></p><div class="doc"><p>Make the stream producer and consumer run concurrently by introducing a
 buffer between them. The producer thread evaluates the input stream until
 the buffer fills, it blocks if the buffer is full until there is space in
 the buffer. The consumer consumes the stream lazily from the buffer.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:applyAsync" class="def">applyAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#applyAsync" class="link">Source</a> <a href="#v:applyAsync" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:-124--36-" title="Streamly.Internal.Data.Stream.IsStream">|$</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:-124--36-" class="def">(|$)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (t m a -&gt; t m b) -&gt; t m a -&gt; t m b <span class="fixity">infixr 0</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#%7C%24" class="link">Source</a> <a href="#v:-124--36-" class="selflink">#</a></p><div class="doc"><p>Parallel transform application operator; applies a stream transformation
 function <code>t m a -&gt; t m b</code> to a stream <code>t m a</code> concurrently; the input stream
 is evaluated asynchronously in an independent thread yielding elements to a
 buffer and the transformation function runs in another thread consuming the
 input from the buffer.  <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:-124--36-" title="Streamly.Internal.Data.Stream.IsStream">|$</a></code> is just like regular function application
 operator <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:-36-" title="Data.Function">$</a></code> except that it is concurrent.</p><p>If you read the signature as <code>(t m a -&gt; t m b) -&gt; (t m a -&gt; t m b)</code> you can
 look at it as a transformation that converts a transform function to a
 buffered concurrent transform function.</p><p>The following code prints a value every second even though each stage adds a
 1 second delay.</p><pre>drain $
   S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x)
     |$ S.repeatM (threadDelay 1000000 &gt;&gt; return 1)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:-124--38-" class="def">(|&amp;)</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; (t m a -&gt; t m b) -&gt; t m b <span class="fixity">infixl 1</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#%7C%26" class="link">Source</a> <a href="#v:-124--38-" class="selflink">#</a></p><div class="doc"><p>Parallel reverse function application operator for streams; just like the
 regular reverse function application operator <code>&amp;</code> except that it is
 concurrent.</p><pre>drain $
      S.repeatM (threadDelay 1000000 &gt;&gt; return 1)
   |&amp; S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; print x)
</pre><p><em>Concurrent</em></p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:36" id="g:36"><h2>Filtering</h2></a><div class="top"><p class="src"><a id="v:filter" class="def">filter</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#filter" class="link">Source</a> <a href="#v:filter" class="selflink">#</a></p><div class="doc"><p>Include only those elements that pass a predicate.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:filterM" class="def">filterM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#filterM" class="link">Source</a> <a href="#v:filterM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:filter" title="Streamly.Internal.Data.Stream.IsStream">filter</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:37" id="g:37"><h2>Deleting Elements</h2></a><div class="top"><p class="src"><a id="v:deleteBy" class="def">deleteBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#deleteBy" class="link">Source</a> <a href="#v:deleteBy" class="selflink">#</a></p><div class="doc"><p>Deletes the first occurrence of the element in the stream that satisfies
 the given equality predicate.</p><pre>&gt; S.toList $ S.deleteBy (==) 3 $ S.fromList [1,3,3,5]
[1,3,5]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:uniq" class="def">uniq</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#uniq" class="link">Source</a> <a href="#v:uniq" class="selflink">#</a></p><div class="doc"><p>Drop repeated elements that are adjacent to each other.</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:38" id="g:38"><h2>Inserting Elements</h2></a><div class="top"><p class="src"><a id="v:insertBy" class="def">insertBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#insertBy" class="link">Source</a> <a href="#v:insertBy" class="selflink">#</a></p><div class="doc"><p><code>insertBy cmp elem stream</code> inserts <code>elem</code> before the first element in
 <code>stream</code> that is less than <code>elem</code> when compared using <code>cmp</code>.</p><pre>insertBy cmp x = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream">mergeBy</a></code> cmp (<code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:yield" title="Streamly.Internal.Data.Stream.IsStream">yield</a></code> x)
</pre><pre>&gt; S.toList $ S.insertBy compare 2 $ S.fromList [1,3,5]
[1,2,3,5]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM" class="def">intersperseM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperseM" class="link">Source</a> <a href="#v:intersperseM" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output before consuming an element of a stream
 except the first one.</p><pre>&gt;&gt;&gt; S.toList $ S.trace putChar $ S.intersperseM (putChar <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> &gt;&gt; return ',') $ S.fromList &quot;hello&quot;
&gt; h.,e.,l.,l.,o&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseM_" class="def">intersperseM_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperseM_" class="link">Source</a> <a href="#v:intersperseM_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect before consuming an element of a stream except the
 first one.</p><pre>&gt;&gt;&gt; S.drain $ S.trace putChar $ S.intersperseM_ (putChar <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code>) $ S.fromList &quot;hello&quot;
&gt; h.e.l.l.o
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intersperse" class="def">intersperse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperse" class="link">Source</a> <a href="#v:intersperse" class="selflink">#</a></p><div class="doc"><p>Insert a pure value between successive elements of a stream.</p><pre>&gt; S.toList $ S.intersperse ',' $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffix" class="def">intersperseSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperseSuffix" class="link">Source</a> <a href="#v:intersperseSuffix" class="selflink">#</a></p><div class="doc"><p>Insert an effect and its output after consuming an element of a stream.</p><pre>&gt;&gt;&gt; S.toList $ S.trace putChar $ S.intersperseSuffix (putChar <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> &gt;&gt; return ',') $ S.fromList &quot;hello&quot;
&gt; h.,e.,l.,l.,o.,&quot;h,e,l,l,o,&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffix_" class="def">intersperseSuffix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperseSuffix_" class="link">Source</a> <a href="#v:intersperseSuffix_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect after consuming an element of a stream.</p><pre>&gt; S.mapM_ putChar $ S.intersperseSuffix_ (threadDelay 1000000) $ S.fromList &quot;hello&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interspersePrefix_" class="def">interspersePrefix_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interspersePrefix_" class="link">Source</a> <a href="#v:interspersePrefix_" class="selflink">#</a></p><div class="doc"><p>Insert a side effect before consuming an element of a stream.</p><pre>&gt;&gt;&gt; S.toList $ S.trace putChar $ S.interspersePrefix_ (putChar <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> &gt;&gt; return ',') $ S.fromList &quot;hello&quot;
&gt; .h.e.l.l.o&quot;hello&quot;
</pre><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:trace_" title="Streamly.Internal.Data.Stream.IsStream">trace_</a></code></p><p><em>Concurrent</em></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intersperseSuffixBySpan" class="def">intersperseSuffixBySpan</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intersperseSuffixBySpan" class="link">Source</a> <a href="#v:intersperseSuffixBySpan" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:intersperseSuffix" title="Streamly.Internal.Data.Stream.IsStream">intersperseSuffix</a></code> but intersperses an effectful action into the
 input stream after every <code>n</code> elements and after the last element.</p><pre>&gt; S.toList $ S.intersperseSuffixBySpan 2 (return ',') $ S.fromList &quot;hello&quot;
&quot;he,ll,o,&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interjectSuffix" class="def">interjectSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interjectSuffix" class="link">Source</a> <a href="#v:interjectSuffix" class="selflink">#</a></p><div class="doc"><p>Intersperse a monadic action into the input stream after every <code>n</code>
 seconds.</p><pre>&gt; S.drain $ S.interjectSuffix 1 (putChar ',') $ S.mapM (\x -&gt; threadDelay 1000000 &gt;&gt; putChar x) $ S.fromList &quot;hello&quot;
&quot;h,e,l,l,o&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:delay" class="def">delay</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#delay" class="link">Source</a> <a href="#v:delay" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds before consuming an element of the
 stream except the first one.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.timestamped $ S.delay 1 $ S.enumerateFromTo 1 3
&gt; (AbsTime (TimeSpec {sec = 2502706, nsec = 751137000}),1)
&gt; (AbsTime (TimeSpec {sec = 2502707, nsec = 743535000}),2)
&gt; (AbsTime (TimeSpec {sec = 2502708, nsec = 749758000}),3)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:delayPost" class="def">delayPost</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#delayPost" class="link">Source</a> <a href="#v:delayPost" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds after consuming an element of a
 stream.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.timestamped $ S.delayPost 1 $ S.enumerateFromTo 1 3
&gt; (AbsTime (TimeSpec {sec = 2502826, nsec = 119030000}),1)
&gt; (AbsTime (TimeSpec {sec = 2502827, nsec = 111393000}),2)
&gt; (AbsTime (TimeSpec {sec = 2502828, nsec = 112221000}),3)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:delayPre" class="def">delayPre</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#delayPre" class="link">Source</a> <a href="#v:delayPre" class="selflink">#</a></p><div class="doc"><p>Introduce a delay of specified seconds before consuming an element of a
 stream.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.timestamped $ S.delayPre 1 $ S.enumerateFromTo 1 3
&gt; (AbsTime (TimeSpec {sec = 2502207, nsec = 533177000}),1)
&gt; (AbsTime (TimeSpec {sec = 2502208, nsec = 530859000}),2)
&gt; (AbsTime (TimeSpec {sec = 2502209, nsec = 531619000}),3)
</pre><p><em>Internal</em></p></div></div><a href="#g:39" id="g:39"><h2>Indexing</h2></a><div class="top"><p class="src"><a id="v:indexed" class="def">indexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#indexed" class="link">Source</a> <a href="#v:indexed" class="selflink">#</a></p><div class="doc"><pre>indexed = S.postscanl' (\(i, _) x -&gt; (i + 1, x)) (-1,undefined)
indexed = S.zipWith (,) (S.enumerateFrom 0)</pre><p>Pair each element in a stream with its index, starting from index 0.</p><pre>&gt; S.toList $ S.indexed $ S.fromList &quot;hello&quot;
[(0,<code>h</code>),(1,<code>e</code>),(2,<code>l</code>),(3,<code>l</code>),(4,<code>o</code>)]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:indexedR" class="def">indexedR</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#indexedR" class="link">Source</a> <a href="#v:indexedR" class="selflink">#</a></p><div class="doc"><pre>indexedR n = S.postscanl' (\(i, _) x -&gt; (i - 1, x)) (n + 1,undefined)
indexedR n = S.zipWith (,) (S.enumerateFromThen n (n - 1))</pre><p>Pair each element in a stream with its index, starting from the
 given index <code>n</code> and counting down.</p><pre>&gt; S.toList $ S.indexedR 10 $ S.fromList &quot;hello&quot;
[(10,<code>h</code>),(9,<code>e</code>),(8,<code>l</code>),(7,<code>l</code>),(6,<code>o</code>)]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:timestamped" class="def">timestamped</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#timestamped" class="link">Source</a> <a href="#v:timestamped" class="selflink">#</a></p><div class="doc"><p>Pair each element in a stream with an absolute timestamp, using a clock of
 10 ms granularity.  The timestamp is generated just before the element is
 consumed.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.timestamped $ S.delay 1 $ S.enumerateFromTo 1 3
(AbsTime (TimeSpec {sec = 2460689, nsec = 641121000}),1)
(AbsTime (TimeSpec {sec = 2460690, nsec = 639334000}),2)
(AbsTime (TimeSpec {sec = 2460691, nsec = 644479000}),3)
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:timeIndexed" class="def">timeIndexed</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Time-Units.html#t:RelTime64" title="Streamly.Internal.Data.Time.Units">RelTime64</a>, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#timeIndexed" class="link">Source</a> <a href="#v:timeIndexed" class="selflink">#</a></p><div class="doc"><p>Pair each element in a stream with relative times starting from 0, using a
 10 ms granularity clock. The time is measured just before the element is
 consumed.</p><pre>&gt;&gt;&gt; S.mapM_ print $ S.timeIndexed $ S.delay 1 $ S.enumerateFromTo 1 3
(RelTime64 (NanoSecond64 0),1)
(RelTime64 (NanoSecond64 996239000),2)
(RelTime64 (NanoSecond64 1996712000),3)
</pre><p><em>Internal</em></p></div></div><a href="#g:40" id="g:40"><h2>Reordering</h2></a><div class="top"><p class="src"><a id="v:reverse" class="def">reverse</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#reverse" class="link">Source</a> <a href="#v:reverse" class="selflink">#</a></p><div class="doc"><p>Returns the elements of the stream in reverse order.  The stream must be
 finite. Note that this necessarily buffers the entire stream in memory.</p><p><em>Since 0.7.0 (Monad m constraint)</em></p><p><em>Since: 0.1.1</em></p></div></div><div class="top"><p class="src"><a id="v:reverse-39-" class="def">reverse'</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#reverse%27" class="link">Source</a> <a href="#v:reverse-39-" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:reverse" title="Streamly.Internal.Data.Stream.IsStream">reverse</a></code> but several times faster, requires a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a></code> instance.</p><p><em>Internal</em></p></div></div><a href="#g:41" id="g:41"><h2>Parsing</h2></a><div class="top"><p class="src"><a id="v:parseMany" class="def">parseMany</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseMany" class="link">Source</a> <a href="#v:parseMany" class="selflink">#</a></p><div class="doc"><p>Apply a <code><a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a></code> repeatedly on a stream and emit the parsed values in the
 output stream.</p><p>This is the streaming equivalent of the <code><a href="Streamly-Internal-Data-Parser.html#v:many" title="Streamly.Internal.Data.Parser">many</a></code>
 parse combinator.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.parseMany (PR.take 2 $ PR.fromFold FL.sum) $ S.fromList [1..10]
</code></strong>&gt; [3,7,11,15,19]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.parseMany (PR.line FL.toList) $ S.fromList &quot;hello\nworld&quot;
</code></strong>&gt; [&quot;hello\n&quot;,&quot;world&quot;]
</pre><p>/Internal</p></div></div><div class="top"><p class="src"><a id="v:parseManyD" class="def">parseManyD</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; <a href="Streamly-Internal-Data-Parser-ParserD-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserD.Types">Parser</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseManyD" class="link">Source</a> <a href="#v:parseManyD" class="selflink">#</a></p></div><div class="top"><p class="src"><a id="v:parseManyTill" class="def">parseManyTill</a> :: <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a x -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseManyTill" class="link">Source</a> <a href="#v:parseManyTill" class="selflink">#</a></p><div class="doc"><p><code>parseManyTill collect test stream</code> tries the parser <code>test</code> on the input,
 if <code>test</code> fails it backtracks and tries <code>collect</code>, after <code>collect</code> succeeds
 <code>test</code> is tried again and so on. The parser stops when <code>test</code> succeeds.  The
 output of <code>test</code> is discarded and the output of <code>collect</code> is emitted in the
 output stream. The parser fails if <code>collect</code> fails.</p><p><em>Unimplemented</em></p></div></div><div class="top"><p class="src"><a id="v:parseIterate" class="def">parseIterate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadThrow" title="Control.Monad.Catch">MonadThrow</a> m) =&gt; (b -&gt; <a href="Streamly-Internal-Data-Parser-ParserK-Types.html#t:Parser" title="Streamly.Internal.Data.Parser.ParserK.Types">Parser</a> m a b) -&gt; b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#parseIterate" class="link">Source</a> <a href="#v:parseIterate" class="selflink">#</a></p><div class="doc"><p>Iterate a parser generating function on a stream. The initial value <code>b</code> is
 used to generate the first parser, the parser is applied on the stream and
 the result is used to generate the next parser and so on.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.map getSum $ S.parseIterate (\b -&gt; PR.take 2 (FL.mconcatTo b)) 0 $ S.map Sum $ S.fromList [1..10]
</code></strong>&gt; [3,10,21,36,55,55]
</pre><p>This is the streaming equivalent of monad like sequenced application of
 parsers where next parser is dependent on the previous parser.</p><p><em>Internal</em></p></div></div><a href="#g:42" id="g:42"><h2>Trimming</h2></a><div class="top"><p class="src"><a id="v:take" class="def">take</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#take" class="link">Source</a> <a href="#v:take" class="selflink">#</a></p><div class="doc"><p>Take first <code>n</code> elements from the stream and discard the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeByTime" class="def">takeByTime</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#takeByTime" class="link">Source</a> <a href="#v:takeByTime" class="selflink">#</a></p><div class="doc"><p><code>takeByTime duration</code> yields stream elements upto specified time
 <code>duration</code>. The duration starts when the stream is evaluated for the first
 time, before the first element is yielded. The time duration is checked
 before generating each element, if the duration has expired the stream
 stops.</p><p>The total time taken in executing the stream is guaranteed to be <em>at least</em>
 <code>duration</code>, however, because the duration is checked before generating an
 element, the upper bound is indeterminate and depends on the time taken in
 generating and processing the last element.</p><p>No element is yielded if the duration is zero. At least one element is
 yielded if the duration is non-zero.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#takeWhile" class="link">Source</a> <a href="#v:takeWhile" class="selflink">#</a></p><div class="doc"><p>End the stream as soon as the predicate fails on an element.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:takeWhileM" class="def">takeWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#takeWhileM" class="link">Source</a> <a href="#v:takeWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:takeWhile" title="Streamly.Internal.Data.Stream.IsStream">takeWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:drop" class="def">drop</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#drop" class="link">Source</a> <a href="#v:drop" class="selflink">#</a></p><div class="doc"><p>Discard first <code>n</code> elements from the stream and take the rest.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropByTime" class="def">dropByTime</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Time-Units.html#t:TimeUnit64" title="Streamly.Internal.Data.Time.Units">TimeUnit64</a> d) =&gt; d -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropByTime" class="link">Source</a> <a href="#v:dropByTime" class="selflink">#</a></p><div class="doc"><p><code>dropByTime duration</code> drops stream elements until specified <code>duration</code> has
 passed.  The duration begins when the stream is evaluated for the first
 time. The time duration is checked <em>after</em> generating a stream element, the
 element is yielded if the duration has expired otherwise it is dropped.</p><p>The time elapsed before starting to generate the first element is <em>at most</em>
 <code>duration</code>, however, because the duration expiry is checked after the
 element is generated, the lower bound is indeterminate and depends on the
 time taken in generating an element.</p><p>All elements are yielded if the duration is zero.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropWhile" class="link">Source</a> <a href="#v:dropWhile" class="selflink">#</a></p><div class="doc"><p>Drop elements in the stream as long as the predicate succeeds and then
 take the rest of the stream.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:dropWhileM" class="def">dropWhileM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#dropWhileM" class="link">Source</a> <a href="#v:dropWhileM" class="selflink">#</a></p><div class="doc"><p>Same as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:dropWhile" title="Streamly.Internal.Data.Stream.IsStream">dropWhile</a></code> but with a monadic predicate.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:43" id="g:43"><h2>Breaking</h2></a><div class="top"><p class="src"><a id="v:chunksOf" class="def">chunksOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#chunksOf" class="link">Source</a> <a href="#v:chunksOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into groups of <code>n</code> elements each and then fold each
 group using the provided fold function.</p><pre>&gt; S.toList $ S.chunksOf 2 FL.sum (S.enumerateFromTo 1 10)
 [3,7,11,15,19]</pre><p>This can be considered as an n-fold version of <code>ltake</code> where we apply
 <code>ltake</code> repeatedly on the leftover stream until the stream exhausts.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:chunksOf2" class="def">chunksOf2</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m c -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold2" title="Streamly.Internal.Data.Fold.Types">Fold2</a> m c a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#chunksOf2" class="link">Source</a> <a href="#v:chunksOf2" class="selflink">#</a></p><div class="doc"><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:arraysOf" class="def">arraysOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m (<a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#arraysOf" class="link">Source</a> <a href="#v:arraysOf" class="selflink">#</a></p><div class="doc"><p><code>arraysOf n stream</code> groups the elements in the input stream into arrays of
 <code>n</code> elements each.</p><p>Same as the following but may be more efficient:</p><pre>arraysOf n = S.chunksOf n (A.writeN n)</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intervalsOf" class="def">intervalsOf</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intervalsOf" class="link">Source</a> <a href="#v:intervalsOf" class="selflink">#</a></p><div class="doc"><p>Group the input stream into windows of <code>n</code> second each and then fold each
 group using the provided fold function.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:44" id="g:44"><h2>Searching</h2></a><div class="top"><p class="src"><a id="v:findIndices" class="def">findIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#findIndices" class="link">Source</a> <a href="#v:findIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the element in the stream satisfies the given
 predicate.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:elemIndices" class="def">elemIndices</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; a -&gt; t m a -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#elemIndices" class="link">Source</a> <a href="#v:elemIndices" class="selflink">#</a></p><div class="doc"><p>Find all the indices where the value of the element in the stream is equal
 to the given value.</p><p><em>Since: 0.5.0</em></p></div></div><a href="#g:45" id="g:45"><h2>Splitting</h2></a><div class="doc"><p>Streams can be sliced into segments in space or in time. We use the
 term <code>chunk</code> to refer to a spatial length of the stream (spatial window)
 and the term <code>session</code> to refer to a length in time (time window).</p></div><div class="top"><p class="src"><a id="v:splitOn" class="def">splitOn</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitOn" class="link">Source</a> <a href="#v:splitOn" class="selflink">#</a></p><div class="doc"><p>Split on an infixed separator element, dropping the separator. Splits the
 stream on separator elements determined by the supplied predicate, separator
 is considered as infixed between two segments, if one side of the separator
 is missing then it is parsed as an empty stream.  The supplied <code><a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a></code> is
 applied on the split segments. With <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing non-separator elements
 and <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream">splitOn</a></code> splits as follows:</p><pre>&quot;--.--&quot; =&gt; &quot;--&quot; &quot;--&quot;
&quot;--.&quot;   =&gt; &quot;--&quot; &quot;&quot;
&quot;.--&quot;   =&gt; &quot;&quot;   &quot;--&quot;
</pre><p><code>splitOn (== x)</code> is an inverse of <code>intercalate (S.yield x)</code></p><p>Let's use the following definition for illustration:</p><pre>splitOn' p xs = S.toList $ S.splitOn p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn' (== '.') &quot;a..b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffix" class="def">splitOnSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitOnSuffix" class="link">Source</a> <a href="#v:splitOnSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream">splitOn</a></code> but the separator is considered as suffixed to the segments
 in the stream. A missing suffix at the end is allowed. A separator at the
 beginning is parsed as empty segment.  With <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#v:-45-" title="Prelude">-</a></code> representing elements and
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as separator, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream">splitOnSuffix</a></code> splits as follows:</p><pre> &quot;--.--.&quot; =&gt; &quot;--&quot; &quot;--&quot;
 &quot;--.--&quot;  =&gt; &quot;--&quot; &quot;--&quot;
 &quot;.--.&quot;   =&gt; &quot;&quot; &quot;--&quot;
</pre><pre>splitOnSuffix' p xs = S.toList $ S.splitSuffixBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitOnSuffix (== '\n')</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffix" class="def">splitWithSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitWithSuffix" class="link">Source</a> <a href="#v:splitWithSuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOnSuffix" title="Streamly.Internal.Data.Stream.IsStream">splitOnSuffix</a></code> but keeps the suffix attached to the resulting
 splits.</p><pre>splitWithSuffix' p xs = S.toList $ S.splitWithSuffix p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitWithSuffix' (== '.') &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wordsBy" class="def">wordsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#wordsBy" class="link">Source</a> <a href="#v:wordsBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream">splitOn</a></code> after stripping leading, trailing, and repeated separators.
 Therefore, <code>&quot;.a..b.&quot;</code> with <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Function.html#v:." title="Data.Function">.</a></code> as the separator would be parsed as
 <code>[&quot;a&quot;,&quot;b&quot;]</code>.  In other words, its like parsing words from whitespace
 separated text.</p><pre>wordsBy' p xs = S.toList $ S.wordsBy p (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,&quot;
</code></strong>&gt; []
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>wordsBy' (== ',') &quot;,a,,b,&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre>words = wordsBy isSpace</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSeq" class="def">splitOnSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitOnSeq" class="link">Source</a> <a href="#v:splitOnSeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOn" title="Streamly.Internal.Data.Stream.IsStream">splitOn</a></code> but the separator is a sequence of elements instead of a
 single element.</p><p>For illustration, let's define a function that operates on pure lists:</p><pre>splitOnSeq' pat xs = S.toList $ S.splitOnSeq (A.fromList pat) (FL.toList) (S.fromList xs)
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;l&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOnSeq' &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;o&quot;]
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream">splitOnSeq</a></code> is an inverse of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:intercalate" title="Streamly.Internal.Data.Stream.IsStream">intercalate</a></code>. The following law always holds:</p><pre>intercalate . splitOn == id</pre><p>The following law holds when the separator is non-empty and contains none of
 the elements present in the input lists:</p><pre>splitOn . intercalate == id</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitOnSuffixSeq" class="def">splitOnSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitOnSuffixSeq" class="link">Source</a> <a href="#v:splitOnSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixBy</code> but the separator is a sequence of elements, instead
 of a predicate for a single element.</p><pre>splitSuffixOn_ pat xs = S.toList $ S.splitSuffixOn (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;&quot;
</code></strong>[]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a&quot;,&quot;&quot;,&quot;b&quot;,&quot;&quot;]
</pre><pre>lines = splitSuffixOn &quot;\n&quot;</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitBySeq" class="def">splitBySeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitBySeq" class="link">Source</a> <a href="#v:splitBySeq" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitOnSeq" title="Streamly.Internal.Data.Stream.IsStream">splitOnSeq</a></code> but splits the separator as well, as an infix token.</p><pre>splitOn'_ pat xs = S.toList $ S.splitOn' (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;&quot;,&quot;e&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;&quot;
</code></strong>&gt; [&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;hello&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;hello&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;x&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;h&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;&quot;,&quot;h&quot;,&quot;ello&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;o&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;hell&quot;,&quot;o&quot;,&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;e&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;h&quot;,&quot;e&quot;,&quot;llo&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;l&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;l&quot;,&quot;&quot;,&quot;l&quot;,&quot;o&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitOn'_ &quot;ll&quot; &quot;hello&quot;
</code></strong>&gt; [&quot;he&quot;,&quot;ll&quot;,&quot;o&quot;]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitWithSuffixSeq" class="def">splitWithSuffixSeq</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Foreign-Storable.html#t:Storable" title="Foreign.Storable">Storable</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Enum" title="Prelude">Enum</a> a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Array-Storable-Foreign-Types.html#t:Array" title="Streamly.Internal.Data.Array.Storable.Foreign.Types">Array</a> a -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitWithSuffixSeq" class="link">Source</a> <a href="#v:splitWithSuffixSeq" class="selflink">#</a></p><div class="doc"><p>Like <code>splitSuffixOn</code> but keeps the suffix intact in the splits.</p><pre>splitSuffixOn'_ pat xs = S.toList $ FL.splitSuffixOn' (A.fromList pat) (FL.toList) (S.fromList xs)</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;&quot;
</code></strong>[&quot;&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;.&quot;
</code></strong>[&quot;.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a&quot;
</code></strong>[&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;.a&quot;
</code></strong>&gt; [&quot;.&quot;,&quot;a&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.&quot;
</code></strong>&gt; [&quot;a.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.b&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a.b.&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;b.&quot;]
</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>splitSuffixOn'_ &quot;.&quot; &quot;a..b..&quot;
</code></strong>&gt; [&quot;a.&quot;,&quot;.&quot;,&quot;b.&quot;,&quot;.&quot;]
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBy" class="def">splitInnerBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitInnerBy" class="link">Source</a> <a href="#v:splitInnerBy" class="selflink">#</a></p><div class="doc"><p><code>splitInnerBy splitter joiner stream</code> splits the inner containers <code>f a</code> of
 an input stream <code>t m (f a)</code> using the <code>splitter</code> function. Container
 elements <code>f a</code> are collected until a split occurs, then all the elements
 before the split are joined using the <code>joiner</code> function.</p><p>For example, if we have a stream of <code>Array Word8</code>, we may want to split the
 stream into arrays representing lines separated by 'n' byte such that the
 resulting stream after a split would be one array for each line.</p><p>CAUTION! This is not a true streaming function as the container size after
 the split and merge may not be bounded.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:splitInnerBySuffix" class="def">splitInnerBySuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> (f a), <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Monoid.html#t:Monoid" title="Data.Monoid">Monoid</a> (f a)) =&gt; (f a -&gt; m (f a, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (f a))) -&gt; (f a -&gt; f a -&gt; m (f a)) -&gt; t m (f a) -&gt; t m (f a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#splitInnerBySuffix" class="link">Source</a> <a href="#v:splitInnerBySuffix" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:splitInnerBy" title="Streamly.Internal.Data.Stream.IsStream">splitInnerBy</a></code> but splits assuming the separator joins the segment in
 a suffix style.</p><p><em>Internal</em></p></div></div><a href="#g:46" id="g:46"><h2>Grouping</h2></a><div class="top"><p class="src"><a id="v:groups" class="def">groups</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a> a) =&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#groups" class="link">Source</a> <a href="#v:groups" class="selflink">#</a></p><div class="doc"><pre>groups = groupsBy (==)
groups = groupsByRolling (==)</pre><p>Groups contiguous spans of equal elements together in individual groups.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groups FL.toList $ S.fromList [1,1,2,2]
</code></strong>&gt; [[1,1],[2,2]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsBy" class="def">groupsBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#groupsBy" class="link">Source</a> <a href="#v:groupsBy" class="selflink">#</a></p><div class="doc"><p><code>groupsBy cmp f $ S.fromList [a,b,c,...]</code> assigns the element <code>a</code> to the
 first group, if <code>b `cmp` a</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same
 group.  If <code>c `cmp` a</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same
 group and so on. When the comparison fails a new group is started. Each
 group is folded using the fold <code>f</code> and the result of the fold is emitted in
 the output stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsBy (&gt;) FL.toList $ S.fromList [1,3,7,0,2,5]
</code></strong>&gt; [[1,3,7],[0,2,5]]
</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:groupsByRolling" class="def">groupsByRolling</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#groupsByRolling" class="link">Source</a> <a href="#v:groupsByRolling" class="selflink">#</a></p><div class="doc"><p>Unlike <code>groupsBy</code> this function performs a rolling comparison of two
 successive elements in the input stream. <code>groupsByRolling cmp f $ S.fromList
 [a,b,c,...]</code> assigns the element <code>a</code> to the first group, if <code>a `cmp` b</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>b</code> is also assigned to the same group.  If <code>b `cmp` c</code> is
 <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then <code>c</code> is also assigned to the same group and so on. When the
 comparison fails a new group is started. Each group is folded using the fold
 <code>f</code>.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.groupsByRolling (\a b -&gt; a + 1 == b) FL.toList $ S.fromList [1,2,3,7,8,9]
</code></strong>&gt; [[1,2,3],[7,8,9]]
</pre><p><em>Since: 0.7.0</em></p></div></div><a href="#g:47" id="g:47"><h2>Group map</h2></a><div class="top"><p class="src"><a id="v:rollingMapM" class="def">rollingMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#rollingMapM" class="link">Source</a> <a href="#v:rollingMapM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rollingMap" title="Streamly.Internal.Data.Stream.IsStream">rollingMap</a></code> but with an effectful map function.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:rollingMap" class="def">rollingMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#rollingMap" class="link">Source</a> <a href="#v:rollingMap" class="selflink">#</a></p><div class="doc"><p>Apply a function on every two successive elements of a stream. If the
 stream consists of a single element the output is an empty stream.</p><p>This is the stream equivalent of the list idiom <code>zipWith f xs (tail xs)</code>.</p><p><em>Internal</em></p></div></div><a href="#g:48" id="g:48"><h1>Windowed Classification</h1></a><div class="doc"><p>Split the stream into windows or chunks in space or time. Each window
 can be associated with a key, all events associated with a particular
 key in the window can be folded to a single result. The stream is split
 into windows of specified size, the window can be terminated early if
 the closing flag is specified in the input stream.</p><p>The term &quot;chunk&quot; is used for a space window and the term &quot;session&quot; is
 used for a time window.</p></div><a href="#g:49" id="g:49"><h2>Tumbling Windows</h2></a><div class="doc"><p>A new window starts after the previous window is finished.</p></div><div class="top"><p class="src"><a id="v:classifySessionsBy" class="def">classifySessionsBy</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#classifySessionsBy" class="link">Source</a> <a href="#v:classifySessionsBy" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>timer tick in seconds</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session timeout in seconds</p></td></tr><tr><td class="src">-&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></td><td class="doc"><p>reset the timeout when an event is received</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions based on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b)</td><td class="doc"><p>Fold to be applied to session events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc"><p>session key, fold result</p></td></tr></table></div><div class="doc"><p><code>classifySessionsBy tick timeout idle pred f stream</code> groups timestamped
 events in an input event stream into sessions based on a session key. Each
 element in the stream is an event consisting of a triple <code>(session key,
 sesssion data, timestamp)</code>.  <code>session key</code> is a key that uniquely identifies
 the session.  All the events belonging to a session are folded using the
 fold <code>f</code> until the fold returns a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> result or a timeout has occurred.
 The session key and the result of the fold are emitted in the output stream
 when the session is purged.</p><p>When <code>idle</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:False" title="Data.Bool">False</a></code>, <code>timeout</code> is the maximum lifetime of a session in
 seconds, measured from the <code>timestamp</code> of the first event in that session.
 When <code>idle</code> is <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> then the timeout is an idle timeout, it is reset after
 every event received in the session.</p><p><code>timestamp</code> in an event characterizes the time when the input event was
 generated, this is an absolute time measured from some <code>Epoch</code>.  The notion
 of current time is maintained by a monotonic event time clock using the
 timestamps seen in the input stream. The latest timestamp seen till now is
 used as the base for the current time.  When no new events are seen, a timer
 is started with a tick duration specified by <code>tick</code>. This timer is used to
 detect session timeouts in the absence of new events.</p><p>The predicate <code>pred</code> is invoked with the current session count, if it
 returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code> a session is ejected from the session cache before inserting
 a new session. This could be useful to alert or eject sessions when the
 number of sessions becomes too high.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:classifySessionsOf" class="def">classifySessionsOf</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#classifySessionsOf" class="link">Source</a> <a href="#v:classifySessionsOf" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>time window size</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b)</td><td class="doc"><p>Fold to be applied to session events</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Split the stream into fixed size time windows of specified interval in
 seconds. Within each such window, fold the elements in sessions identified
 by the session keys. The fold result is emitted in the output stream if the
 fold returns a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code> result or if the time window ends.</p><p>Session <code>timestamp</code> in the input stream is an absolute time from some epoch,
 characterizing the time when the input element was generated.  To detect
 session window end, a monotonic event time clock is maintained synced with
 the timestamps with a clock resolution of 1 second.</p><p>If the ejection predicate returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the session with the longest
 lifetime is ejected before inserting a new session.</p><pre>classifySessionsOf interval pred = classifySessionsBy 1 interval False pred
</pre><pre>&gt;&gt;&gt; S.mapM_ print
  $ S.classifySessionsOf 3 (const (return False)) (fmap Right FL.toList)
  $ S.map ((ts,(k,a)) -&gt; (k, a, ts))
  $ S.timestamped
  $ S.delay 1
  $ (,) <a href="$">$</a> S.fromList [1,2,3] <a href="*">*</a> S.fromList [1,2,3]
</pre><p><em>Internal</em></p></div></div><a href="#g:50" id="g:50"><h2>Keep Alive Windows</h2></a><div class="doc"><p>The window size is extended if an event arrives within the specified
 window size. This can represent sessions with idle or inactive timeout.</p></div><div class="top"><p class="src"><a id="v:classifyKeepAliveSessions" class="def">classifyKeepAliveSessions</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#classifyKeepAliveSessions" class="link">Source</a> <a href="#v:classifyKeepAliveSessions" class="selflink">#</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ord" title="Data.Ord">Ord</a> k)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></td><td class="doc"><p>session inactive timeout</p></td></tr><tr><td class="src">-&gt; (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>)</td><td class="doc"><p>predicate to eject sessions on session count</p></td></tr><tr><td class="src">-&gt; <a href="Streamly-Internal-Data-Fold-Types.html#t:Fold" title="Streamly.Internal.Data.Fold.Types">Fold</a> m a (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> b b)</td><td class="doc"><p>Fold to be applied to session payload data</p></td></tr><tr><td class="src">-&gt; t m (k, a, <a href="Streamly-Internal-Data-Time-Units.html#t:AbsTime" title="Streamly.Internal.Data.Time.Units">AbsTime</a>)</td><td class="doc"><p>session key, data, timestamp</p></td></tr><tr><td class="src">-&gt; t m (k, b)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:classifySessionsOf" title="Streamly.Internal.Data.Stream.IsStream">classifySessionsOf</a></code> but the session is kept alive if an event is
 received within the session window. The session times out and gets closed
 only if no event is received within the specified session window size.</p><p>If the ejection predicate returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#v:True" title="Data.Bool">True</a></code>, the session that was idle for
 the longest time is ejected before inserting a new session.</p><pre>classifyKeepAliveSessions timeout pred = classifySessionsBy 1 timeout True pred
</pre><p><em>Internal</em></p></div></div><a href="#g:51" id="g:51"><h2>Sliding Window Buffers</h2></a><a href="#g:52" id="g:52"><h1>Combining Streams</h1></a><a href="#g:53" id="g:53"><h2>Appending</h2></a><div class="top"><p class="src"><a id="v:serial" class="def">serial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.StreamK.Type.html#serial" class="link">Source</a> <a href="#v:serial" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code>SerialT</code>.
 Appends two streams sequentially, yielding all elements from the first
 stream, and then all elements from the second stream.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:append" class="def">append</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#append" class="link">Source</a> <a href="#v:append" class="selflink">#</a></p><div class="doc"><p>Append the outputs of two streams, yielding all the elements from the
 first stream and then yielding all the elements from the second stream.</p><p>IMPORTANT NOTE: This could be 100x faster than <code>serial/&lt;&gt;</code> for appending a
 few (say 100) streams because it can fuse via stream fusion. However, it
 does not scale for a large number of streams (say 1000s) and becomes
 qudartically slow. Therefore use this for custom appending of a few streams
 but use <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream">concatMap</a></code> or 'concatMapWith serial' for appending <code>n</code> streams or
 infinite containers of streams.</p><p><em>Internal</em></p></div></div><a href="#g:54" id="g:54"><h2>Interleaving</h2></a><div class="top"><p class="src"><a id="v:interleave" class="def">interleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interleave" class="link">Source</a> <a href="#v:interleave" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. If any of the streams finishes
 early the other stream continues alone until it too finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,,,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleave &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,cd&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream">interleave</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream">interleaveMin</a></code>, it can be called <code>interleaveMax</code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveMin" class="def">interleaveMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interleaveMin" class="link">Source</a> <a href="#v:interleaveMin" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. The output stops as soon as any
 of the two streams finishes, discarding the remaining part of the other
 stream. The last element of the resulting stream would be from the longer
 stream.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;ab&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveMin &quot;abcd&quot; &quot;,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveMin" title="Streamly.Internal.Data.Stream.IsStream">interleaveMin</a></code> is dual to <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream">interleave</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveSuffix" class="def">interleaveSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interleaveSuffix" class="link">Source</a> <a href="#v:interleaveSuffix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream. As soon as the first stream
 finishes, the output stops, discarding the remaining part of the second
 stream. In this case, the last element in the resulting stream would be from
 the second stream. If the second stream finishes early then the first stream
 still continues to yield elements until it finishes.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c,&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveSuffix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream">interleaveSuffix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream">interleaveInfix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interleaveInfix" class="def">interleaveInfix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interleaveInfix" class="link">Source</a> <a href="#v:interleaveInfix" class="selflink">#</a></p><div class="doc"><p>Interleaves the outputs of two streams, yielding elements from each stream
 alternately, starting from the first stream and ending at the first stream.
 If the second stream is longer than the first, elements from the second
 stream are infixed with elements from the first stream. If the first stream
 is longer then it continues yielding elements even after the second stream
 has finished.</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>:set -XOverloadedStrings
</code></strong><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,,,,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,b,c&quot;
<code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>interleaveInfix &quot;abc&quot; &quot;,&quot; :: SerialT Identity Char
</code></strong>fromList &quot;a,bc&quot;
</pre><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream">interleaveInfix</a></code> is a dual of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream">interleaveSuffix</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:wSerial" class="def">wSerial</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerial" class="link">Source</a> <a href="#v:wSerial" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WSerialT" title="Streamly.Internal.Data.Stream.IsStream">WSerialT</a></code>.
 Interleaves two streams, yielding one element from each stream alternately.
 When one stream stops the rest of the other stream is used in the output
 stream.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialFst" class="def">wSerialFst</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialFst" class="link">Source</a> <a href="#v:wSerialFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream">wSerial</a></code> but stops interleaving as soon as the first stream stops.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:wSerialMin" class="def">wSerialMin</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Serial.html#wSerialMin" class="link">Source</a> <a href="#v:wSerialMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:wSerial" title="Streamly.Internal.Data.Stream.IsStream">wSerial</a></code> but stops interleaving as soon as any of the two streams
 stops.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:55" id="g:55"><h2>Scheduling</h2></a><div class="top"><p class="src"><a id="v:ahead" class="def">ahead</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Ahead.html#ahead" class="link">Source</a> <a href="#v:ahead" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AheadT" title="Streamly.Internal.Data.Stream.IsStream">AheadT</a></code>.
 Merges two streams sequentially but with concurrent lookahead.</p><p><em>Since: 0.3.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:async" class="def">async</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#async" class="link">Source</a> <a href="#v:async" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:AsyncT" title="Streamly.Internal.Data.Stream.IsStream">AsyncT</a></code>.
 Merges two streams possibly concurrently, preferring the
 elements from the left one when available.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:wAsync" class="def">wAsync</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Async.html#wAsync" class="link">Source</a> <a href="#v:wAsync" class="selflink">#</a></p><div class="doc"><p>Polymorphic version of the <code><a href="Streamly.html#t:Semigroup" title="Streamly">Semigroup</a></code> operation <code><a href="Streamly.html#v:-60--62-" title="Streamly">&lt;&gt;</a></code> of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:WAsyncT" title="Streamly.Internal.Data.Stream.IsStream">WAsyncT</a></code>.
 Merges two streams concurrently choosing elements from both fairly.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:roundrobin" class="def">roundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m b -&gt; t m b -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#roundrobin" class="link">Source</a> <a href="#v:roundrobin" class="selflink">#</a></p><div class="doc"><p>Schedule the execution of two streams in a fair round-robin manner,
 executing each stream once, alternately. Execution of a stream may not
 necessarily result in an output, a stream may chose to <code>Skip</code> producing an
 element until later giving the other stream a chance to run. Therefore, this
 combinator fairly interleaves the execution of two streams rather than
 fairly interleaving the output of the two streams. This can be useful in
 co-operative multitasking without using explicit threads. This can be used
 as an alternative to <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:async" title="Streamly.Internal.Data.Stream.IsStream">async</a></code>.</p><p>Do not use at scale in concatMapWith.</p><p><em>Internal</em></p></div></div><a href="#g:56" id="g:56"><h2>Parallel</h2></a><div class="top"><p class="src"><a id="v:parallel" class="def">parallel</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <span class="fixity">infixr 6</span><span class="rightedge"></span> <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallel" class="link">Source</a> <a href="#v:parallel" class="selflink">#</a></p><div class="doc"><p>Execute two streams concurrently and merge their outputs.  For example, if
 stream <code>a</code> is a serial stream consisting of <code>a1, a2, a3</code> and stream <code>b</code> is a
 serial stream consisting of <code>b1, b2, b3</code> then stream <code>a <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream">parallel</a></code> b</code> may
 produce <code>a1, b1, a2, b2, a3, b3</code> or <code>a1, a2, b1, a3, b2, b3</code> or some other
 combination depending on the rate at which the two streams produce elements.
 However, the relative order of outputs from a single stream e.g. <code>a1, a2,
 a3</code> would remain the same in the resulting stream. The effects in the two
 streams may occur concurrently.</p><p>To run single actions (instead of streams) in parallel wrap them into
 singleton streams.  The following trivial example is semantically equivalent
 to running the action <code>putStrLn &quot;hello&quot;</code> in the current thread:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (putStrLn &quot;hello&quot;) `parallel` S.nil
</code></strong>&gt; hello
&gt; [()]
</pre><p>Run two actions concurrently:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (putStrLn &quot;hello&quot;) `parallel` S.yieldM (putStrLn &quot;world&quot;)
</code></strong>&gt; hello
&gt; world
&gt; [(),()]
</pre><p>Run effects concurrently, disregarding their outputs:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.nilM (putStrLn &quot;hello&quot;) `parallel` S.nilM (putStrLn &quot;world&quot;)
</code></strong>&gt; hello
&gt; world
&gt; []
</pre><p>Run an effectful action, and a pure effect without any output, concurrently:</p><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>S.toList $ S.yieldM (return 1) `parallel` S.nilM (putStrLn &quot;world&quot;)
</code></strong>world
[1]
</pre><p>Note that <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream">parallel</a></code> is a polymorphic version of the <code>Semigroup</code> operation
 <code>&lt;&gt;</code> of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:ParallelT" title="Streamly.Internal.Data.Stream.IsStream">ParallelT</a></code>.</p><p><code>nilM</code> is currently <code>Internal</code>.</p><p><em>Since: 0.2.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:parallelFst" class="def">parallelFst</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallelFst" class="link">Source</a> <a href="#v:parallelFst" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream">parallel</a></code> but stops the output as soon as the first stream stops.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:parallelMin" class="def">parallelMin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Parallel.html#parallelMin" class="link">Source</a> <a href="#v:parallelMin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream">parallel</a></code> but stops the output as soon as any of the two streams
 stops.</p><p><em>Internal</em></p></div></div><a href="#g:57" id="g:57"><h2>Merging</h2></a><div class="top"><p class="src"><a id="v:mergeBy" class="def">mergeBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mergeBy" class="link">Source</a> <a href="#v:mergeBy" class="selflink">#</a></p><div class="doc"><p>Merge two streams using a comparison function. The head elements of both
 the streams are compared and the smaller of the two elements is emitted, if
 both elements are equal then the element from the first stream is used
 first.</p><p>If the streams are sorted in ascending order, the resulting stream would
 also remain sorted in ascending order.</p><pre>&gt; S.toList $ S.mergeBy compare (S.fromList [1,3,5]) (S.fromList [2,4,6,8])
[1,2,3,4,5,6,8]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeByM" class="def">mergeByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mergeByM" class="link">Source</a> <a href="#v:mergeByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream">mergeBy</a></code> but with a monadic comparison function.</p><p>Merge two streams randomly:</p><pre>&gt; randomly _ _ = randomIO &gt;&gt;= x -&gt; return $ if x then LT else GT
&gt; S.toList $ S.mergeByM randomly (S.fromList [1,1,1,1]) (S.fromList [2,2,2,2])
[2,1,2,2,2,1,1,1]
</pre><p>Merge two streams in a proportion of 2:1:</p><pre>proportionately m n = do
 ref &lt;- newIORef $ cycle $ concat [replicate m LT, replicate n GT]
 return $ \_ _ -&gt; do
     r &lt;- readIORef ref
     writeIORef ref $ tail r
     return $ head r

main = do
 f &lt;- proportionately 2 1
 xs &lt;- S.toList $ S.mergeByM f (S.fromList [1,1,1,1,1,1]) (S.fromList [2,2,2])
 print xs
</pre><pre>[1,1,2,1,1,2,1,1,2]
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncBy" class="def">mergeAsyncBy</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mergeAsyncBy" class="link">Source</a> <a href="#v:mergeAsyncBy" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mergeBy" title="Streamly.Internal.Data.Stream.IsStream">mergeBy</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:mergeAsyncByM" class="def">mergeAsyncByM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; a -&gt; m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Ord.html#t:Ordering" title="Data.Ord">Ordering</a>) -&gt; t m a -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mergeAsyncByM" class="link">Source</a> <a href="#v:mergeAsyncByM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mergeByM" title="Streamly.Internal.Data.Stream.IsStream">mergeByM</a></code> but merges concurrently (i.e. both the elements being
 merged are generated concurrently).</p><p><em>Since: 0.6.0</em></p></div></div><a href="#g:58" id="g:58"><h2>Zipping</h2></a><div class="top"><p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipWith" class="link">Source</a> <a href="#v:zipWith" class="selflink">#</a></p><div class="doc"><p>Zip two streams serially using a pure zipping function.</p><pre>&gt; S.toList $ S.zipWith (+) (S.fromList [1,2,3]) (S.fromList [4,5,6])
[5,7,9]
</pre><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipWithM" class="def">zipWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipWithM" class="link">Source</a> <a href="#v:zipWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream">zipWith</a></code> but using a monadic zipping function.</p><p><em>Since: 0.4.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWith" class="def">zipAsyncWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipAsyncWith" class="link">Source</a> <a href="#v:zipAsyncWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:zipWith" title="Streamly.Internal.Data.Stream.IsStream">zipWith</a></code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:zipAsyncWithM" class="def">zipAsyncWithM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m) =&gt; (a -&gt; b -&gt; m c) -&gt; t m a -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.Zip.html#zipAsyncWithM" class="link">Source</a> <a href="#v:zipAsyncWithM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:zipWithM" title="Streamly.Internal.Data.Stream.IsStream">zipWithM</a></code> but zips concurrently i.e. both the streams being zipped
 are generated concurrently.</p><p><em>Since: 0.4.0</em></p></div></div><a href="#g:59" id="g:59"><h2>Flattening a Container of Streams</h2></a><div class="top"><p class="src"><a id="v:concatFoldableWith" class="def">concatFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; f (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatFoldableWith" class="link">Source</a> <a href="#v:concatFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:fold" title="Data.Foldable">fold</a></code> that allows you to fold a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code>
 container of streams using the specified stream sum operation.</p><pre>concatFoldableWith <code>async</code> $ map return [1..3]</pre><p>Equivalent to:</p><pre>concatFoldableWith f = S.concatMapFoldableWith f id
</pre><p><em>Since: 0.8.0 (Renamed foldWith to concatFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapFoldableWith" class="def">concatMapFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; f a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatMapFoldableWith" class="link">Source</a> <a href="#v:concatMapFoldableWith" class="selflink">#</a></p><div class="doc"><p>A variant of <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#v:foldMap" title="Data.Foldable">foldMap</a></code> that allows you to map a monadic streaming action
 on a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a></code> container and then fold it using the specified stream merge
 operation.</p><pre>concatMapFoldableWith <code>async</code> return [1..3]</pre><p>Equivalent to:</p><pre>concatMapFoldableWith f g xs = S.concatMapWith f g (S.fromFoldable xs)
</pre><p><em>Since: 0.8.0 (Renamed foldMapWith to concatMapFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><div class="top"><p class="src"><a id="v:concatForFoldableWith" class="def">concatForFoldableWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; f a -&gt; (a -&gt; t m b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.Prelude.html#concatForFoldableWith" class="link">Source</a> <a href="#v:concatForFoldableWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMapFoldableWith" title="Streamly.Internal.Data.Stream.IsStream">concatMapFoldableWith</a></code> but with the last two arguments reversed i.e. the
 monadic streaming function is the last argument.</p><p>Equivalent to:</p><pre>concatForFoldableWith = flip S.concatMapFoldableWith
</pre><p><em>Since: 0.8.0 (Renamed forEachWith to concatForFoldableWith)</em></p><p><em>Since: 0.1.0 (<a href="Streamly.html">Streamly</a>)</em></p></div></div><a href="#g:60" id="g:60"><h2>Flattening a Stream of Streams</h2></a><div class="top"><p class="src"><a id="v:concat" class="def">concat</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concat" class="link">Source</a> <a href="#v:concat" class="selflink">#</a></p><div class="doc"><p>Flatten a stream of streams to a single stream.</p><pre>concat = concatMap id
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatM" class="def">concatM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m (t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatM" class="link">Source</a> <a href="#v:concatM" class="selflink">#</a></p><div class="doc"><p>Given a stream value in the underlying monad, lift and join the underlying
 monad with the stream monad.</p><pre>concatM = concat . yieldM
concatM = concat . lift    -- requires <code>(MonadTrans t)</code>
concatM = join . lift      -- requires <code>(MonadTrans t</code>, <code>Monad (t m))</code>
</pre><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concat" title="Streamly.Internal.Data.Stream.IsStream">concat</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:sequence" title="Streamly.Internal.Data.Stream.IsStream">sequence</a></code></p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatMap" class="link">Source</a> <a href="#v:concatMap" class="selflink">#</a></p><div class="doc"><p>Map a stream producing function on each element of the stream and then
 flatten the results into a single stream.</p><pre>concatMap f = 'concat . map f'
concatMap = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMapWith" title="Streamly.Internal.Data.Stream.IsStream">concatMapWith</a></code> <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream">serial</a></code>
concatMap f = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMapM" title="Streamly.Internal.Data.Stream.IsStream">concatMapM</a></code> (return . f)
concatMap f = <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream">concatUnfold</a></code> (UF.lmap f UF.fromStream)
</pre><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapM" class="def">concatMapM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; m (t m b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatMapM" class="link">Source</a> <a href="#v:concatMapM" class="selflink">#</a></p><div class="doc"><p>Map a stream producing monadic function on each element of the stream
 and then flatten the results into a single stream. Since the stream
 generation function is monadic, unlike <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream">concatMap</a></code>, it can produce an
 effect at the beginning of each iteration of the inner loop.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatMapWith" class="def">concatMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (a -&gt; t m b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatMapWith" class="link">Source</a> <a href="#v:concatMapWith" class="selflink">#</a></p><div class="doc"><p><code>concatMapWith merge map stream</code> is a two dimensional looping combinator.
 The first argument specifies a merge or concat function that is used to
 merge the streams generated by applying the second argument i.e. the <code>map</code>
 function to each element of the input stream. The concat function could be
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:serial" title="Streamly.Internal.Data.Stream.IsStream">serial</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallel" title="Streamly.Internal.Data.Stream.IsStream">parallel</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:async" title="Streamly.Internal.Data.Stream.IsStream">async</a></code>, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:ahead" title="Streamly.Internal.Data.Stream.IsStream">ahead</a></code> or any other zip or merge function
 and the second argument could be any stream generation function using a
 seed.</p><p><em>Compare <code>foldMapWith</code></em></p><p><em>Since: 0.7.0</em></p><p><em>Since: 0.8.0 (signature change)</em></p></div></div><div class="top"><p class="src"><a id="v:concatSmapMWith" class="def">concatSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m b -&gt; t m b -&gt; t m b) -&gt; (s -&gt; a -&gt; m (s, t m b)) -&gt; m s -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatSmapMWith" class="link">Source</a> <a href="#v:concatSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMapWith" title="Streamly.Internal.Data.Stream.IsStream">concatMapWith</a></code> but carries a state which can be used to share
 information across multiple steps of concat.</p><pre>concatSmapMWith combine f initial = concatMapWith combine id . smapM f initial
</pre><p><em>Internal</em></p></div></div><a href="#g:61" id="g:61"><h2>Flattening Using Unfolds</h2></a><div class="top"><p class="src"><a id="v:concatUnfold" class="def">concatUnfold</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatUnfold" class="link">Source</a> <a href="#v:concatUnfold" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream">concatMap</a></code> but uses an <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> for stream generation. Unlike
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatMap" title="Streamly.Internal.Data.Stream.IsStream">concatMap</a></code> this can fuse the <code><a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a></code> code with the inner loop and
 therefore provide many times better performance.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldInterleave" class="def">concatUnfoldInterleave</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatUnfoldInterleave" class="link">Source</a> <a href="#v:concatUnfoldInterleave" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream">concatUnfold</a></code> but interleaves the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleave" title="Streamly.Internal.Data.Stream.IsStream">interleave</a></code> behaves instead of appending them.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:concatUnfoldRoundrobin" class="def">concatUnfoldRoundrobin</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a b -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#concatUnfoldRoundrobin" class="link">Source</a> <a href="#v:concatUnfoldRoundrobin" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:concatUnfold" title="Streamly.Internal.Data.Stream.IsStream">concatUnfold</a></code> but executes the streams in the same way as
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:roundrobin" title="Streamly.Internal.Data.Stream.IsStream">roundrobin</a></code>.</p><p><em>Internal</em></p></div></div><a href="#g:62" id="g:62"><h2>Flattening a Tree of Streams</h2></a><div class="top"><p class="src"><a id="v:iterateMapWith" class="def">iterateMapWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (a -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#iterateMapWith" class="link">Source</a> <a href="#v:iterateMapWith" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:iterateM" title="Streamly.Internal.Data.Stream.IsStream">iterateM</a></code> but iterates after mapping a stream generator on the
 output.</p><p>Yield an input element in the output stream, map a stream generator on it
 and then do the same on the resulting stream. This can be used for a depth
 first traversal of a tree like structure.</p><p>Note that <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:iterateM" title="Streamly.Internal.Data.Stream.IsStream">iterateM</a></code> is a special case of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream">iterateMapWith</a></code>:</p><pre>iterateM f = iterateMapWith serial (yieldM . f) . yieldM
</pre><p>It can be used to traverse a tree structure.  For example, to list a
 directory tree:</p><pre>Stream.iterateMapWith Stream.serial
    (either Dir.toEither (const nil))
    (yield (Left &quot;tmp&quot;))
</pre><p><em>Internal</em></p></div></div><a href="#g:63" id="g:63"><h2>Flattening a Graph of Streams</h2></a><div class="top"><p class="src"><a id="v:iterateSmapMWith" class="def">iterateSmapMWith</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (t m a -&gt; t m a -&gt; t m a) -&gt; (b -&gt; a -&gt; m (b, t m a)) -&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#iterateSmapMWith" class="link">Source</a> <a href="#v:iterateSmapMWith" class="selflink">#</a></p><div class="doc"><p>Like <code>iterateMap</code> but carries a state in the stream generation function.
 This can be used to traverse graph like structures, we can remember the
 visited nodes in the state to avoid cycles.</p><p>Note that a combination of <code>iterateMap</code> and <code>usingState</code> can also be used to
 traverse graphs. However, this function provides a more localized state
 instead of using a global state.</p><p>See also: <code>mfix</code></p><p><em>Internal</em></p></div></div><a href="#g:64" id="g:64"><h2>Inserting Streams in Streams</h2></a><div class="top"><p class="src"><a id="v:gintercalate" class="def">gintercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#gintercalate" class="link">Source</a> <a href="#v:gintercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveInfix" title="Streamly.Internal.Data.Stream.IsStream">interleaveInfix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:gintercalateSuffix" class="def">gintercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m a c -&gt; t m a -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#gintercalateSuffix" class="link">Source</a> <a href="#v:gintercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:interleaveSuffix" title="Streamly.Internal.Data.Stream.IsStream">interleaveSuffix</a></code> followed by unfold and concat.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intercalate" class="def">intercalate</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intercalate" class="link">Source</a> <a href="#v:intercalate" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:intersperse" title="Streamly.Internal.Data.Stream.IsStream">intersperse</a></code> followed by unfold and concat.</p><pre>unwords = intercalate &quot; &quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot; &quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc def ghi&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:intercalateSuffix" class="def">intercalateSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; b -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#intercalateSuffix" class="link">Source</a> <a href="#v:intercalateSuffix" class="selflink">#</a></p><div class="doc"><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:intersperseSuffix" title="Streamly.Internal.Data.Stream.IsStream">intersperseSuffix</a></code> followed by unfold and concat.</p><pre>unlines = intercalateSuffix &quot;\n&quot; UF.fromList</pre><pre class="screen"><code class="prompt">&gt;&gt;&gt; </code><strong class="userinput"><code>intercalate &quot;\n&quot; UF.fromList [&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;]
</code></strong>&gt; &quot;abc\ndef\nghi\n&quot;
</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interpose" class="def">interpose</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interpose" class="link">Source</a> <a href="#v:interpose" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, intersperse the given element between the
 unfolded streams and then concat them into a single stream.</p><pre>unwords = S.interpose ' '</pre><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:interposeSuffix" class="def">interposeSuffix</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; c -&gt; <a href="Streamly-Internal-Data-Unfold-Types.html#t:Unfold" title="Streamly.Internal.Data.Unfold.Types">Unfold</a> m b c -&gt; t m b -&gt; t m c <a href="src/Streamly.Internal.Data.Stream.IsStream.html#interposeSuffix" class="link">Source</a> <a href="#v:interposeSuffix" class="selflink">#</a></p><div class="doc"><p>Unfold the elements of a stream, append the given element after each
 unfolded stream and then concat them into a single stream.</p><pre>unlines = S.interposeSuffix '\n'</pre><p><em>Internal</em></p></div></div><a href="#g:65" id="g:65"><h1>Exceptions</h1></a><div class="top"><p class="src"><a id="v:before" class="def">before</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#before" class="link">Source</a> <a href="#v:before" class="selflink">#</a></p><div class="doc"><p>Run a side effect before the stream yields its first element.</p><pre>before action xs = 'nilM' action &lt;&gt; xs</pre><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:after_" class="def">after_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#after_" class="link">Source</a> <a href="#v:after_" class="selflink">#</a></p><div class="doc"><p>Run a side effect at the end of the stream. The side effect won't run if
 the stream is garbage collected before it reached the end.</p><pre>after_ action xs = xs &lt;&gt; 'nilM' action</pre><p>This has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:after" title="Streamly.Internal.Data.Stream.IsStream">after</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:after" class="def">after</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m, <a href="https://hackage.haskell.org/package/monad-control-1.0.2.3/docs/Control-Monad-Trans-Control.html#t:MonadBaseControl" title="Control.Monad.Trans.Control">MonadBaseControl</a> <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/System-IO.html#t:IO" title="System.IO">IO</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#after" class="link">Source</a> <a href="#v:after" class="selflink">#</a></p><div class="doc"><p>Run a side effect at the end of the stream or if it is garbage collected
 even before reaching the end.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:bracket_" class="def">bracket_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#bracket_" class="link">Source</a> <a href="#v:bracket_" class="selflink">#</a></p><div class="doc"><p>Run the first action before the stream starts and remember its output,
 generate a stream using the output, run the second action using the
 remembered value as an argument whenever the stream ends normally or due to
 an exception. The second action won't run if the stream is garbage collected
 before it could reach the end.</p><p>This has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:bracket" title="Streamly.Internal.Data.Stream.IsStream">bracket</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:bracket" class="def">bracket</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; (b -&gt; m c) -&gt; (b -&gt; t m a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#bracket" class="link">Source</a> <a href="#v:bracket" class="selflink">#</a></p><div class="doc"><p>Run the first action before the stream starts and remember its output,
 generate a stream using the output, run the second action using the
 remembered value as an argument whenever the stream ends normally, due to
 an exception or if it is garbage collected after a partial lazy evaluation.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:onException" class="def">onException</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#onException" class="link">Source</a> <a href="#v:onException" class="selflink">#</a></p><div class="doc"><p>Run a side effect whenever the stream aborts due to an exception.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:finally_" class="def">finally_</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#finally_" class="link">Source</a> <a href="#v:finally_" class="selflink">#</a></p><div class="doc"><p>Run a side effect at the end of the stream or if it aborts due to an
 exception before it could reach the end. The side effect is not run if the
 stream is garbage collected before reaching the end.</p><p>This has slightly better performance than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:finally" title="Streamly.Internal.Data.Stream.IsStream">finally</a></code>.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:finally" class="def">finally</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m) =&gt; m b -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#finally" class="link">Source</a> <a href="#v:finally" class="selflink">#</a></p><div class="doc"><p>Run a side effect at the end of the stream, or if it aborts due to an
 exception or if it is garbage collected before it could reach the end.</p><p><em>Since: 0.7.0</em></p></div></div><div class="top"><p class="src"><a id="v:handle" class="def">handle</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/exceptions-0.10.4/docs/Control-Monad-Catch.html#t:MonadCatch" title="Control.Monad.Catch">MonadCatch</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Exception-Base.html#t:Exception" title="Control.Exception.Base">Exception</a> e) =&gt; (e -&gt; t m a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#handle" class="link">Source</a> <a href="#v:handle" class="selflink">#</a></p><div class="doc"><p>When evaluating a stream if an exception occurs, stream evaluation aborts
 and the specified exception handler is run with the exception as argument.</p><p><em>Since: 0.7.0</em></p></div></div><a href="#g:66" id="g:66"><h1>Generalize Inner Monad</h1></a><div class="top"><p class="src"><a id="v:hoist" class="def">hoist</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> n) =&gt; (<span class="keyword">forall</span> x. m x -&gt; n x) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> n a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#hoist" class="link">Source</a> <a href="#v:hoist" class="selflink">#</a></p><div class="doc"><p>Transform the inner monad of a stream using a natural transformation.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:generally" class="def">generally</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; t <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a> a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#generally" class="link">Source</a> <a href="#v:generally" class="selflink">#</a></p><div class="doc"><p>Generalize the inner monad of the stream from <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor-Identity.html#t:Identity" title="Data.Functor.Identity">Identity</a></code> to any monad.</p><p><em> Internal</em></p></div></div><a href="#g:67" id="g:67"><h1>Transform Inner Monad</h1></a><div class="top"><p class="src"><a id="v:liftInner" class="def">liftInner</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/transformers-0.5.6.2/docs/Control-Monad-Trans-Class.html#t:MonadTrans" title="Control.Monad.Trans.Class">MonadTrans</a> tr, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> (tr m)) =&gt; t m a -&gt; t (tr m) a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#liftInner" class="link">Source</a> <a href="#v:liftInner" class="selflink">#</a></p><div class="doc"><p>Lift the inner monad <code>m</code> of a stream <code>t m a</code> to <code>tr m</code> using the monad
 transformer <code>tr</code>.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:usingReaderT" class="def">usingReaderT</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m r -&gt; (t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> r m) a -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> r m) a) -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#usingReaderT" class="link">Source</a> <a href="#v:usingReaderT" class="selflink">#</a></p><div class="doc"><p>Run a stream transformation using a given environment.</p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:map" title="Streamly.Internal.Data.Stream.IsStream">map</a></code></p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:runReaderT" class="def">runReaderT</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; m s -&gt; t (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a> s m) a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#runReaderT" class="link">Source</a> <a href="#v:runReaderT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader.html#t:ReaderT" title="Control.Monad.Reader">ReaderT</a></code>.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:evalStateT" class="def">evalStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#evalStateT" class="link">Source</a> <a href="#v:evalStateT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a></code>.</p><p>This is supported only for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:usingStateT" class="def">usingStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#usingStateT" class="link">Source</a> <a href="#v:usingStateT" class="selflink">#</a></p><div class="doc"><p>Run a stateful (StateT) stream transformation using a given state.</p><p>This is supported only for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p>See also: <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code></p><p><em> Internal</em></p></div></div><div class="top"><p class="src"><a id="v:runStateT" class="def">runStateT</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; m s -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> (<a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a> s m) a -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m (s, a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#runStateT" class="link">Source</a> <a href="#v:runStateT" class="selflink">#</a></p><div class="doc"><p>Evaluate the inner monad of a stream as <code><a href="https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Strict.html#t:StateT" title="Control.Monad.State.Strict">StateT</a></code> and emit the resulting
 state and value pair after each step.</p><p>This is supported only for <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code> as concurrent state updation may not be
 safe.</p><p><em> Internal</em></p></div></div><a href="#g:68" id="g:68"><h1>Maybe Streams</h1></a><div class="top"><p class="src"><a id="v:catMaybes" class="def">catMaybes</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#catMaybes" class="link">Source</a> <a href="#v:catMaybes" class="selflink">#</a></p><div class="doc"><p>In a stream of <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code>s, discard <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>s and unwrap <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>s.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybe" class="def">mapMaybe</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mapMaybe" class="link">Source</a> <a href="#v:mapMaybe" class="selflink">#</a></p><div class="doc"><p>Map a <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a></code> returning function to a stream, filter out the <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>
 elements, and return a stream of values extracted from <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Just" title="Data.Maybe">Just</a></code>.</p><p>Equivalent to:</p><pre>mapMaybe f = S.map <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . S.filter <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . S.map f
</pre><p><em>Since: 0.3.0</em></p></div></div><div class="top"><p class="src"><a id="v:mapMaybeM" class="def">mapMaybeM</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:MonadAsync" title="Streamly.Internal.Data.Stream.IsStream">MonadAsync</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; (a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b)) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#mapMaybeM" class="link">Source</a> <a href="#v:mapMaybeM" class="selflink">#</a></p><div class="doc"><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:mapMaybe" title="Streamly.Internal.Data.Stream.IsStream">mapMaybe</a></code> but maps a monadic function.</p><p>Equivalent to:</p><pre>mapMaybeM f = S.map <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:fromJust" title="Data.Maybe">fromJust</a></code> . S.filter <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:isJust" title="Data.Maybe">isJust</a></code> . S.mapM f
</pre><p><em>Concurrent (do not use with <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:parallely" title="Streamly.Internal.Data.Stream.IsStream">parallely</a></code> on infinite streams)</em></p><p><em>Since: 0.3.0</em></p></div></div><a href="#g:69" id="g:69"><h1>Either Streams</h1></a><div class="top"><p class="src"><a id="v:lefts" class="def">lefts</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#lefts" class="link">Source</a> <a href="#v:lefts" class="selflink">#</a></p><div class="doc"><p>Discard <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Right" title="Data.Either">Right</a></code>s and unwrap <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s in an <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:rights" class="def">rights</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Functor.html#t:Functor" title="Data.Functor">Functor</a> (t m)) =&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#rights" class="link">Source</a> <a href="#v:rights" class="selflink">#</a></p><div class="doc"><p>Discard <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s and unwrap <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Right" title="Data.Either">Right</a></code>s in an <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream.</p><p><em>Internal</em></p></div></div><div class="top"><p class="src"><a id="v:iterateMapLeftsWith" class="def">iterateMapLeftsWith</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; (t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; (a -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b)) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) -&gt; t m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a> a b) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#iterateMapLeftsWith" class="link">Source</a> <a href="#v:iterateMapLeftsWith" class="selflink">#</a></p><div class="doc"><p>In an <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#t:Either" title="Data.Either">Either</a></code> stream iterate on <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Either.html#v:Left" title="Data.Either">Left</a></code>s.  This is a special case of
 <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:iterateMapWith" title="Streamly.Internal.Data.Stream.IsStream">iterateMapWith</a></code>:</p><pre>iterateMapLeftsWith combine f = iterateMapWith combine (either f (const nil))
</pre><p>To traverse a directory tree:</p><pre>iterateMapLeftsWith serial Dir.toEither (yield (Left &quot;tmp&quot;))
</pre><p><em>Internal</em></p></div></div><a href="#g:70" id="g:70"><h1>Concurrency Control</h1></a><div class="top"><p class="src"><a id="v:maxThreads" class="def">maxThreads</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxThreads" class="link">Source</a> <a href="#v:maxThreads" class="selflink">#</a></p><div class="doc"><p>Specify the maximum number of threads that can be spawned concurrently for
 any concurrent combinator in a stream.
 A value of 0 resets the thread limit to default, a negative value means
 there is no limit. The default value is 1500. <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream">maxThreads</a></code> does not affect
 <code>ParallelT</code> streams as they can use unbounded number of threads.</p><p>When the actions in a stream are IO bound, having blocking IO calls, this
 option can be used to control the maximum number of in-flight IO requests.
 When the actions are CPU bound this option can be used to
 control the amount of CPU used by the stream.</p><p><em>Since: 0.4.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxBuffer" class="def">maxBuffer</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxBuffer" class="link">Source</a> <a href="#v:maxBuffer" class="selflink">#</a></p><div class="doc"><p>Specify the maximum size of the buffer for storing the results from
 concurrent computations. If the buffer becomes full we stop spawning more
 concurrent tasks until there is space in the buffer.
 A value of 0 resets the buffer size to default, a negative value means
 there is no limit. The default value is 1500.</p><p>CAUTION! using an unbounded <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream">maxBuffer</a></code> value (i.e. a negative value)
 coupled with an unbounded <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream">maxThreads</a></code> value is a recipe for disaster in
 presence of infinite streams, or very large streams.  Especially, it must
 not be used when <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> is used in <code>ZipAsyncM</code> streams as <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Applicative.html#v:pure" title="Control.Applicative">pure</a></code> in
 applicative zip streams generates an infinite stream causing unbounded
 concurrent generation with no limit on the buffer or threads.</p><p><em>Since: 0.4.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:71" id="g:71"><h1>Rate Limiting</h1></a><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Rate" class="def">Rate</a> <a href="src/Streamly.Internal.Data.SVar.html#Rate" class="link">Source</a> <a href="#t:Rate" class="selflink">#</a></p><div class="doc"><p>Specifies the stream yield rate in yields per second (<code>Hertz</code>).
 We keep accumulating yield credits at <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream">rateGoal</a></code>. At any point of time we
 allow only as many yields as we have accumulated as per <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream">rateGoal</a></code> since the
 start of time. If the consumer or the producer is slower or faster, the
 actual rate may fall behind or exceed <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream">rateGoal</a></code>.  We try to recover the gap
 between the two by increasing or decreasing the pull rate from the producer.
 However, if the gap becomes more than <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream">rateBuffer</a></code> we try to recover only as
 much as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream">rateBuffer</a></code>.</p><p><code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateLow" title="Streamly.Internal.Data.Stream.IsStream">rateLow</a></code> puts a bound on how low the instantaneous rate can go when
 recovering the rate gap.  In other words, it determines the maximum yield
 latency.  Similarly, <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateHigh" title="Streamly.Internal.Data.Stream.IsStream">rateHigh</a></code> puts a bound on how high the instantaneous
 rate can go when recovering the rate gap.  In other words, it determines the
 minimum yield latency. We reduce the latency by increasing concurrency,
 therefore we can say that it puts an upper bound on concurrency.</p><p>If the <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateGoal" title="Streamly.Internal.Data.Stream.IsStream">rateGoal</a></code> is 0 or negative the stream never yields a value.
 If the <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:rateBuffer" title="Streamly.Internal.Data.Stream.IsStream">rateBuffer</a></code> is 0 or negative we do not attempt to recover.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:Rate" class="def">Rate</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><ul><li><dfn class="src"><a id="v:rateLow" class="def">rateLow</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The lower rate limit</p></div></li><li><dfn class="src"><a id="v:rateGoal" class="def">rateGoal</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The target rate we want to achieve</p></div></li><li><dfn class="src"><a id="v:rateHigh" class="def">rateHigh</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a></dfn><div class="doc"><p>The upper rate limit</p></div></li><li><dfn class="src"><a id="v:rateBuffer" class="def">rateBuffer</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a></dfn><div class="doc"><p>Maximum slack from the goal</p></div></li></ul></div></td></tr></table></div></div><div class="top"><p class="src"><a id="v:rate" class="def">rate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> <a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#rate" class="link">Source</a> <a href="#v:rate" class="selflink">#</a></p><div class="doc"><p>Specify the pull rate of a stream.
 A <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> value resets the rate to default which is unlimited.  When the
 rate is specified, concurrent production may be ramped up or down
 automatically to achieve the specified yield rate. The specific behavior for
 different styles of <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a></code> specifications is documented under <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:Rate" title="Streamly.Internal.Data.Stream.IsStream">Rate</a></code>.  The
 effective maximum production rate achieved by a stream is governed by:</p><ul><li>The <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxThreads" title="Streamly.Internal.Data.Stream.IsStream">maxThreads</a></code> limit</li><li>The <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:maxBuffer" title="Streamly.Internal.Data.Stream.IsStream">maxBuffer</a></code> limit</li><li>The maximum rate that the stream producer can achieve</li><li>The maximum rate that the stream consumer can achieve</li></ul><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:avgRate" class="def">avgRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#avgRate" class="link">Source</a> <a href="#v:avgRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r (2*r) maxBound)</code></p><p>Specifies the average production rate of a stream in number of yields
 per second (i.e.  <code>Hertz</code>).  Concurrent production is ramped up or down
 automatically to achieve the specified average yield rate. The rate can
 go down to half of the specified rate on the lower side and double of
 the specified rate on the higher side.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:minRate" class="def">minRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#minRate" class="link">Source</a> <a href="#v:minRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r (2*r) maxBound)</code></p><p>Specifies the minimum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go below the
 specified rate, even though it may possibly go above it at times, the
 upper limit is double of the specified rate.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:maxRate" class="def">maxRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#maxRate" class="link">Source</a> <a href="#v:maxRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate (r/2) r r maxBound)</code></p><p>Specifies the maximum rate at which the stream should yield values. As
 far as possible the yield rate would never be allowed to go above the
 specified rate, even though it may possibly go below it at times, the
 lower limit is half of the specified rate. This can be useful in
 applications where certain resource usage must not be allowed to go
 beyond certain limits.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><div class="top"><p class="src"><a id="v:constRate" class="def">constRate</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Prelude.html#t:Double" title="Prelude">Double</a> -&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#constRate" class="link">Source</a> <a href="#v:constRate" class="selflink">#</a></p><div class="doc"><p>Same as <code>rate (Just $ Rate r r r 0)</code></p><p>Specifies a constant yield rate. If for some reason the actual rate
 goes above or below the specified rate we do not try to recover it by
 increasing or decreasing the rate in future.  This can be useful in
 applications like graphics frame refresh where we need to maintain a
 constant refresh rate.</p><p><em>Since: 0.5.0 (<a href="Streamly.html">Streamly</a>)</em></p><p><em>Since: 0.8.0</em></p></div></div><a href="#g:72" id="g:72"><h1>Diagnostics</h1></a><div class="top"><p class="src"><a id="v:inspectMode" class="def">inspectMode</a> :: <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t =&gt; t m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.Combinators.html#inspectMode" class="link">Source</a> <a href="#v:inspectMode" class="selflink">#</a></p><div class="doc"><p>Print debug information about an SVar when the stream ends</p><p><em>Internal</em></p></div></div><a href="#g:73" id="g:73"><h1>Deprecated</h1></a><div class="top"><p class="src"><a id="v:once" class="def">once</a> :: (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m, <a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t) =&gt; m a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.StreamK.html#once" class="link">Source</a> <a href="#v:once" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use yieldM instead.</p></div><p>Same as yieldM</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:each" class="def">each</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Foldable.html#t:Foldable" title="Data.Foldable">Foldable</a> f) =&gt; f a -&gt; t m a <a href="src/Streamly.Internal.Data.Stream.IsStream.html#each" class="link">Source</a> <a href="#v:each" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use fromFoldable instead.</p></div><p>Same as <code>fromFoldable</code>.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:scanx" class="def">scanx</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m) =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; t m a -&gt; t m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#scanx" class="link">Source</a> <a href="#v:scanx" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use scanl followed by map instead.</p></div><p>Strict left scan with an extraction function. Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:scanl-39-" title="Streamly.Internal.Data.Stream.IsStream">scanl'</a></code>, but applies a
 user supplied extraction function (the third argument) at each step. This is
 designed to work with the <code>foldl</code> library. The suffix <code>x</code> is a mnemonic for
 extraction.</p><p><em>Since 0.2.0</em></p><p><em>Since: 0.7.0 (Monad m constraint)</em></p></div></div><div class="top"><p class="src"><a id="v:foldx" class="def">foldx</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldx" class="link">Source</a> <a href="#v:foldx" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use foldl' followed by fmap instead.</p></div><p>Strict left fold with an extraction function. Like the standard strict
 left fold, but applies a user supplied extraction function (the third
 argument) to the folded value at the end. This is designed to work with the
 <code>foldl</code> library. The suffix <code>x</code> is a mnemonic for extraction.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldxM" class="def">foldxM</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m b <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldxM" class="link">Source</a> <a href="#v:foldxM" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use foldlM' followed by fmap instead.</p></div><p>Like <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:foldx" title="Streamly.Internal.Data.Stream.IsStream">foldx</a></code>, but with a monadic step function.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; a -&gt; a) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m (<a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> a) <a href="src/Streamly.Internal.Data.Stream.IsStream.html#foldr1" class="link">Source</a> <a href="#v:foldr1" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Use foldrM instead.</p></div><p>Lazy right fold for non-empty streams, using first element as the starting
 value. Returns <code><a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code> if the stream is empty.</p><p><em>Since: 0.5.0</em></p></div></div><div class="top"><p class="src"><a id="v:runStream" class="def">runStream</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#runStream" class="link">Source</a> <a href="#v:runStream" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drain&quot; instead</p></div><p>Run a stream, discarding the results. By default it interprets the stream
 as <code><a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a></code>, to run other types of streams use the type adapting
 combinators for example <code>runStream . <code><a href="Streamly-Internal-Data-Stream-IsStream.html#v:asyncly" title="Streamly.Internal.Data.Stream.IsStream">asyncly</a></code></code>.</p><p><em>Since: 0.2.0</em></p></div></div><div class="top"><p class="src"><a id="v:runN" class="def">runN</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Int.html#t:Int" title="Data.Int">Int</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#runN" class="link">Source</a> <a href="#v:runN" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drainN&quot; instead</p></div><pre>runN n = runStream . take n</pre><p>Run maximum up to <code>n</code> iterations of a stream.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:runWhile" class="def">runWhile</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad.html#t:Monad" title="Control.Monad">Monad</a> m =&gt; (a -&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m a -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#runWhile" class="link">Source</a> <a href="#v:runWhile" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use &quot;drainWhile&quot; instead</p></div><pre>runWhile p = runStream . takeWhile p</pre><p>Run a stream as long as the predicate holds true.</p><p><em>Since: 0.6.0</em></p></div></div><div class="top"><p class="src"><a id="v:fromHandle" class="def">fromHandle</a> :: (<a href="Streamly-Internal-Data-Stream-IsStream.html#t:IsStream" title="Streamly.Internal.Data.Stream.IsStream">IsStream</a> t, <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m) =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; t m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> <a href="src/Streamly.Internal.Data.Stream.IsStream.html#fromHandle" class="link">Source</a> <a href="#v:fromHandle" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use Streamly.FileSystem.Handle module (see the changelog)</p></div><p>Read lines from an IO Handle into a stream of Strings.</p><p><em>Since: 0.1.0</em></p></div></div><div class="top"><p class="src"><a id="v:toHandle" class="def">toHandle</a> :: <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Control-Monad-IO-Class.html#t:MonadIO" title="Control.Monad.IO.Class">MonadIO</a> m =&gt; <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/GHC-IO-Handle.html#t:Handle" title="GHC.IO.Handle">Handle</a> -&gt; <a href="Streamly-Internal-Data-Stream-IsStream.html#t:SerialT" title="Streamly.Internal.Data.Stream.IsStream">SerialT</a> m <a href="https://hackage.haskell.org/package/base-4.14.1.0/docs/Data-String.html#t:String" title="Data.String">String</a> -&gt; m () <a href="src/Streamly.Internal.Data.Stream.IsStream.html#toHandle" class="link">Source</a> <a href="#v:toHandle" class="selflink">#</a></p><div class="doc"><div class="warning"><p>Deprecated: Please use Streamly.FileSystem.Handle module (see the changelog)</p></div><pre>toHandle h = S.mapM_ $ hPutStrLn h
</pre><p>Write a stream of Strings to an IO Handle.</p><p><em>Since: 0.1.0</em></p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>